<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>FengZhao&#39;s Blog</title>
  
  <subtitle>「闲言碎语」</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://fengzhao.me/"/>
  <updated>2019-01-16T17:22:18.838Z</updated>
  <id>https://fengzhao.me/</id>
  
  <author>
    <name>fengzhao</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>nginx-logrotation-日志切割</title>
    <link href="https://fengzhao.me/2019/01/14/nginx-logrotation/"/>
    <id>https://fengzhao.me/2019/01/14/nginx-logrotation/</id>
    <published>2019-01-14T15:36:14.000Z</published>
    <updated>2019-01-16T17:22:18.838Z</updated>
    
    <content type="html"><![CDATA[<h1 id="nginx日志"><a href="#nginx日志" class="headerlink" title="nginx日志"></a>nginx日志</h1><p>在 nginx 中，主要有 access 日志、error 日志 、 rewrite 日志。前两种由ngx_http_log_module模块予以支持，rewrite日志则由ngx_http_rewrite_module模块提供，这两个模块默认都已包含且启用。</p><p>- </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;nginx日志&quot;&gt;&lt;a href=&quot;#nginx日志&quot; class=&quot;headerlink&quot; title=&quot;nginx日志&quot;&gt;&lt;/a&gt;nginx日志&lt;/h1&gt;&lt;p&gt;在 nginx 中，主要有 access 日志、error 日志 、 rewrite 日志。前两种由
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Docker-compose简明教程</title>
    <link href="https://fengzhao.me/2019/01/03/Docker-compose%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B/"/>
    <id>https://fengzhao.me/2019/01/03/Docker-compose简明教程/</id>
    <published>2019-01-03T15:00:49.000Z</published>
    <updated>2019-01-03T15:05:54.079Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>docker-compose 是一个定义和运行多个 docker 容器实例的工具。它使用一个 docker-compose.yml（yaml格式）来定义一组关联的容器应用为一个项目（porject）。通过一个简单的命令，可以创建启动yml中配置的多个容器。它可以在所有的环境中使用，包括生产，开发，测试，持续集成环境。</p><a id="more"></a><p>docker-compose中有两个重要概念：</p><ul><li><p>服务（service）：一个应用的容器，实际上可以包括若干运行相同镜像的容器实例。</p></li><li><p>项目（project）：由一组关联的应用容器组成的一个完整业务单元。</p></li></ul><p>可以看出，一个项目可以由多个服务（容器）关联而成，Compose 面向项目进行管理。</p><p>docker-compose有很多命令，用于容器应用的整个生命周期：</p><ul><li>启动，停止，重建服务。</li><li>查看运行中服务的状态。</li><li>流式输出运行中服务的日志。</li><li>对服务运行的命令。</li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>一般在 Linux 中直接下载二进制文件即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> sudo curl -L "https://github.com/docker/compose/releases/download/1.22.0/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span> sudo chmod +x /usr/local/bin/docker-compose</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span> docker-compose --version</span><br><span class="line">docker-compose version 1.22.0, build f46880fe</span><br></pre></td></tr></table></figure><h3 id="开始使用docker-compose"><a href="#开始使用docker-compose" class="headerlink" title="开始使用docker-compose"></a>开始使用docker-compose</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建文件夹 dockertest ，在该目录中编写app.py，内容为</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> redis</span><br><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">cache = redis.Redis(host=<span class="string">'redis'</span>, port=<span class="number">6379</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_hit_count</span><span class="params">()</span>:</span></span><br><span class="line">    retries = <span class="number">5</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">return</span> cache.incr(<span class="string">'hits'</span>)</span><br><span class="line">        <span class="keyword">except</span> redis.exceptions.ConnectionError <span class="keyword">as</span> exc:</span><br><span class="line">            <span class="keyword">if</span> retries == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">raise</span> exc</span><br><span class="line">            retries -= <span class="number">1</span></span><br><span class="line">            time.sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.route('/')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    count = get_hit_count()</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello World! I have been seen &#123;&#125; times.\n'</span>.format(count)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    app.run(host=<span class="string">"0.0.0.0"</span>, debug=<span class="keyword">True</span>)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="comment">#编写 Dockerfile 文件，内容为</span></span><br><span class="line"></span><br><span class="line">FROM python:<span class="number">3.6</span>-alpine</span><br><span class="line">ADD . /code</span><br><span class="line">WORKDIR /code</span><br><span class="line">RUN pip install redis flask</span><br><span class="line">CMD [<span class="string">"python"</span>, <span class="string">"app.py"</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#编写 docker-compose.yml 文件，内容为</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">version: <span class="string">'3'</span></span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    build: .</span><br><span class="line">    ports:</span><br><span class="line">     - <span class="string">"5000:5000"</span></span><br><span class="line">  redis:</span><br><span class="line">    image: <span class="string">"redis:alpine"</span></span><br></pre></td></tr></table></figure><p>docker-compose.yml 文件中定义两个服务：web 和redis。</p><p>web：使用了Dockerfile中构建的镜像，把容器中的5000端口映射到宿主机的8300端口。</p><p>redis：使用了从 Docker Hub registry 中拉取的官方 redis 镜像。</p><h3 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h3><p>docker-compose的基本使用格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line">  docker-compose [-f &lt;arg&gt;...] [options] [COMMAND] [ARGS...]</span><br><span class="line">  docker-compose --help</span><br><span class="line">  docker-compose command --help</span><br></pre></td></tr></table></figure><h4 id="选项说明"><a href="#选项说明" class="headerlink" title="选项说明"></a>选项说明</h4><ul><li><code>-f  FILE</code>     指定使用的 compose 模板文件（显示指定文件路径），默认为当前目录下的 docker-compose.yml ，如果没有则报错。</li><li><code>-p NAME</code> 指定项目名称，默认将使用所在目录名称作为项目名。</li><li><code>--verbose</code>  显示详细输出。</li><li><code>--log-level LEVEL</code>  设置日志级别 (DEBUG, INFO, WARNING, ERROR, CRITICAL)。</li><li><code>-v, --version</code>  打印版本并退出。</li></ul><h4 id="命令说明"><a href="#命令说明" class="headerlink" title="命令说明"></a>命令说明</h4><h5 id="build"><a href="#build" class="headerlink" title="build"></a>build</h5><p>构建或重建项目中的服务容器。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Usage: build [options] [--build-arg key=val...] [SERVICE...]</span><br></pre></td></tr></table></figure><p>服务容器一旦构建后，将会带上一个标记名，例如对于 web 项目中的一个 db 容器，可能是 web_db。<br>可以随时在项目目录下运行 <code>docker-compose build</code> 来重新构建服务。</p><p>选项包括：</p><ul><li><code>--force-rm</code> 删除构建过程中的临时容器。</li><li><code>--no-cache</code>  构建镜像过程中不使用 cache（这将加长构建过程）。</li><li><code>--pull</code> 始终尝试通过 pull 来获取更新版本的镜像。</li><li><code>-m, --memory MEM</code> 为创建的容器设置内存限制</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h3&gt;&lt;p&gt;docker-compose 是一个定义和运行多个 docker 容器实例的工具。它使用一个 docker-compose.yml（yaml格式）来定义一组关联的容器应用为一个项目（porject）。通过一个简单的命令，可以创建启动yml中配置的多个容器。它可以在所有的环境中使用，包括生产，开发，测试，持续集成环境。&lt;/p&gt;
    
    </summary>
    
    
      <category term="docker" scheme="https://fengzhao.me/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker入门概述</title>
    <link href="https://fengzhao.me/2019/01/03/docker%E5%85%A5%E9%97%A8%E6%A6%82%E8%BF%B0/"/>
    <id>https://fengzhao.me/2019/01/03/docker入门概述/</id>
    <published>2019-01-03T14:48:46.000Z</published>
    <updated>2019-01-13T16:21:22.757Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Docker-概述"><a href="#Docker-概述" class="headerlink" title="Docker 概述"></a>Docker 概述</h2><p>Docker是一个开发，运输和运行应用程序的开放平台。 Docker使您可以将应用程序与基础架构分离，以便快速交付软件。使用Docker，您可以像管理应用程序一样管理基础架构。通过利用Docker的方法快速发送，测试和部署代码，您可以显着减少编写代码和在生产中运行代码之间的延迟。</p><p>Docker提供了在称为容器的松散隔离环境中打包和运行应用程序的功能。隔离和安全性允许您在给定主机上同时运行多个容器。容器是轻量级的，因为它们不需要管理程序的额外负载，而是直接在主机内核中运行。这意味着您可以在给定硬件组合上运行比使用虚拟机时更多的容器。您甚至可以在实际虚拟机的主机中运行Docker容器！</p><a id="more"></a><p>开发者可以根据配置文件将应用及依赖包放到一个可移植的容器中，然后发布到一定版本以上的任何流行的操作系统上，实现轻量级别的虚拟化。容器完全使用沙箱机制，通过镜像来保证运行环境的一致性，启动速度秒级之内，可以更好的满足云计算的自动化以及弹性扩容等场景。</p><p>Docker 可以在容器内部快速自动化的部署应用，并通过操作系统内核技术( namespaces 、cgroups 等)为容器提供资源隔离与安全保障。<br>Docker 是以 Docker 容器为资源分割和调度的基本单位，封装整个软件运行时环境为开发者和系统管理员设计的，用于构建、发布和运行分布式应用的平台。Docker 是一个跨平台、可移植并且简单易用的容器解决方案。</p><p>关于 Docker 中一些 更详细的描述和定义，可以参考下面这几篇网站：</p><blockquote><p><a href="https://www.docker.com/" target="_blank" rel="noopener">https://www.docker.com/</a></p><p><a href="http://guide.daocloud.io/dcs/docker-9153160.html" target="_blank" rel="noopener">http://guide.daocloud.io/dcs/docker-9153160.html</a></p><p><a href="https://www.163yun.com/help/documents/158369209000316928" target="_blank" rel="noopener">https://www.163yun.com/help/documents/158369209000316928</a></p></blockquote><h3 id="Docker-引擎"><a href="#Docker-引擎" class="headerlink" title="Docker 引擎"></a>Docker 引擎</h3><p>Docker Engine是一个客户端 - 服务器应用程序，包含以下主要组件：</p><ul><li>服务端，是一种长时间运行的程序（守护进程），称为 docker daemon（dockerd命令）。</li><li>REST API 接口，它指定程序可以用来与守护进程通信并指示它做什么的接口。</li><li>客户端命令行（ command line interface）（docker命令）。</li></ul><p><img src="engine-components-flow.png" alt="engine-components-flow"></p><p>docker 客户端命令或 REST API 可以与服务端通讯，向服务端的守护进程下达指令。</p><p>docker daemon 创建和管理Docker对象，例如镜像，容器，网络和数据卷等。</p><h3 id="Docker架构"><a href="#Docker架构" class="headerlink" title="Docker架构"></a>Docker架构</h3><p>Docker 使用的是 c/s 架构，Docker 客户端与 Docker 守护进程通讯，后者负责构建，运行，分发 Docker 容器。Docker 客户端和守护进程可以在同一台机器，也可以用 Docker 客户端连接远端 docker 守护进程。Docker自带的客户端程序是通过 Unix socket 套接字文件来与服务端通讯，Docker 官方也提供了 REST 风格的 API，你也可以开发自己的客户端来使用 HTTP 协议来与服务端通讯。</p><p><img src="docker-architecture.png" alt="docker-architecture"></p><center>docker架构图</center><h4 id="docker-守护进程"><a href="#docker-守护进程" class="headerlink" title="docker 守护进程"></a>docker 守护进程</h4><p>Docker守护程序（<code>dockerd</code>）监听 Docker API 请求并管理 Docker 对象，如图像，容器，网络和卷。守护程序还可以与其他守护程序通信以管理 Docker 服务。</p><h4 id="docker-客户端"><a href="#docker-客户端" class="headerlink" title="docker 客户端"></a>docker 客户端</h4><p>Docker客户端（<code>docker</code>）是许多 Docker 用户与 Docker 交互的主要方式。当您使用诸如docker run之类的命令时，客户端会将这些命令发送到 <code>dockerd</code> ，后者将其执行。 <code>docker</code> 命令使用 Docker API 。 Docker 客户端可以与多个守护进程通信。</p><h4 id="Docker-Registry"><a href="#Docker-Registry" class="headerlink" title="Docker Registry"></a>Docker Registry</h4><p>Docker Registry 就是一个镜像商店，它里面可以包括各种镜像，可以分为私有仓库和公有仓库（其中 docker hub 最为出名，它是由 docker 公司开发，国内有阿里云等镜像市场）。我们常用的各种开源软件和运行时环境，基本上都可以在 registry 上找到 docker 镜像。</p><p>一个 Docker Registry 中可以包含多个仓库（<code>Repository</code>）；每个仓库可以包含多个标签（<code>Tag</code>）；每个标签对应一个镜像。  </p><blockquote><p>注意：docker registry是镜像站点，仓库是镜像商店内的软件，人们常说的搭建私有仓库，应该理解成搭建私有docker registry。这与 maven 或者其他私有代码仓库的概念有些区别。</p></blockquote><p>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本。我们可以通过 <code>&lt;仓库名&gt;:&lt;标签&gt;</code> 的格式来指定具体是哪个软件哪个版本的镜像。如果不给出标签，将以 <code>latest</code> 作为默认标签。</p><p>以 <a href="https://store.docker.com/images/ubuntu" target="_blank" rel="noopener">Ubuntu 镜像</a> 为例，<code>ubuntu</code> 是仓库的名字，其内包含有不同的版本标签，如，<code>14.04</code>, <code>16.04</code>。我们可以通过 <code>ubuntu:14.04</code>，或者 <code>ubuntu:16.04</code> 来具体指定所需哪个版本的镜像。如果忽略了标签，比如 <code>ubuntu</code>，那将视为 <code>ubuntu:latest</code>。</p><h4 id="Docker-对象"><a href="#Docker-对象" class="headerlink" title="Docker 对象"></a>Docker 对象</h4><p>使用 Docker 时，将会创建和使用镜像，容器，网络，数据卷，插件和其他对象。这些介绍其中一些对象。</p><p>镜像：镜像是一个轻量级，独立的，可执行的软件包，它包括运行这个软件的一切：代码，运行时，系统等。</p><p>容器：容器就是运行启动起来的镜像。同一个镜像可以启动多个，可以简单理解为容器就是镜像的实例化。</p><p>关于容器和镜像的基本概念，可以参考<a href="http://dockone.io/article/6051" target="_blank" rel="noopener">这篇文章</a>，我认为这篇文章名副其实，把 docker 的基本概念介绍的非常清楚。</p><h3 id="安装-docker"><a href="#安装-docker" class="headerlink" title="安装 docker"></a>安装 docker</h3><p>docker的安装见官网安装教程：</p><blockquote><p><a href="https://docs.docker.com/install/" target="_blank" rel="noopener">https://docs.docker.com/install/</a></p></blockquote><h4 id="第一个-docker-实例"><a href="#第一个-docker-实例" class="headerlink" title="第一个 docker 实例"></a>第一个 docker 实例</h4><p>看完一大堆理论，赶紧去运行你的第一个 docker 容器吧。docker的使用非常方便。 </p><p>一句命令就可以启动 一个 nginx ，感受一下 docker 的方便吧：</p><p>docker run -d -p 8080:80 nginx </p><p>其中 -d 指后台运行，-p 将容器内的 80 端口映射到宿主机的 8080 端口上。</p><p>启动完访问宿主机的 8080 端口，就能见到熟悉的 nginx 欢迎界面了。</p><h3 id="配置-docker"><a href="#配置-docker" class="headerlink" title="配置 docker"></a>配置 docker</h3><h4 id="运行-docker"><a href="#运行-docker" class="headerlink" title="运行 docker"></a>运行 docker</h4><p>安装好 docker 之后，一般 docker 守护进程会自动启动，我们可以通过直接启动或系统服务的方式来启动 docker。</p><h5 id="直接启动"><a href="#直接启动" class="headerlink" title="直接启动"></a>直接启动</h5><p>直接执行 dockerd 命令就可以启动守护进程，它会在前台运行，输出启动日志到终端，使用 ctr+c 命令来停止进程。可以用这种方式来进行测试。</p><h5 id="开机启动"><a href="#开机启动" class="headerlink" title="开机启动"></a>开机启动</h5><p>大多数当前的Linux发行版（RHEL，CentOS，Fedora，Ubuntu 16.04 及更高版本）使用 systemd 工具来管理系统启动时启动的服务。 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> systemctl enable docker  #开机自启</span><br><span class="line"><span class="meta">$</span> systemctl disable docker #开机自启</span><br><span class="line"><span class="meta">$</span> systemctl start docker   #启动docker</span><br><span class="line"><span class="meta">$</span> systemctl restart docker #重启</span><br><span class="line"><span class="meta">$</span> systemctl stop docker    #重启</span><br><span class="line"><span class="meta">$</span> systemctl status docker  #查看状态</span><br></pre></td></tr></table></figure><h4 id="服务端配置"><a href="#服务端配置" class="headerlink" title="服务端配置"></a>服务端配置</h4><p>docker 守护进程的配置，有两种方式指定：</p><ul><li>通过在 dockerd 命令后面指定启动参数。</li><li>通过 dockerd  –config-file  来指定一个json 格式的配置文件 （默认在/etc/docker/daemon.json）</li></ul><p>默认地，这个配置文件不存在，系统按照默认配置启动 docker ，如果想自定义，可以创建这个文件。下面是一个简单的示例：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"debug"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"tls"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"tlscert"</span>: <span class="string">"/var/docker/server.pem"</span>,</span><br><span class="line">  <span class="attr">"tlskey"</span>: <span class="string">"/var/docker/serverkey.pem"</span>,</span><br><span class="line">  <span class="attr">"hosts"</span>: [<span class="string">"tcp://192.168.59.3:2376"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个配置文件指定以调试模式启动，开启 TLS 安全传输协议，证书和密钥路径，并监听到 192.168.59.3:2376 。这与下面这个命令是一样的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dockerd --debug \</span><br><span class="line">  --tls=true \</span><br><span class="line">  --tlscert=/var/docker/server.pem \</span><br><span class="line">  --tlskey=/var/docker/serverkey.pem \</span><br><span class="line">  --host tcp://192.168.59.3:2376</span><br></pre></td></tr></table></figure><p>具体的配置选项可以参考 <a href="https://docs.docker.com/engine/reference/commandline/dockerd/" target="_blank" rel="noopener">dockerd reference doc</a> 或者使用 dockerd –help来查看。</p><h4 id="远程访问"><a href="#远程访问" class="headerlink" title="远程访问"></a>远程访问</h4><p>docker 守护进程使用 unix, tcp, fd 三种类型的 Socket 通信来监听 <a href="https://docs.docker.com/develop/sdk/" target="_blank" rel="noopener">Docker Engine API</a> 。</p><p>默认地，docker 会创建一个 /var/run/docker.sock 文件，它只允许本地的 root 用户来连接，它需要 root 权限，或 docker 用户组。通常我们不建议开启远程访问。</p><p>默认地，docker 没有开启远程访问，如果需要开启远程访问，需要开启 tcp socket 通讯，需要注意的是，默认安装没有启用对服务端访问的加密和认证。也就是说一旦开启远程访问和服务器外网，任何人都可以通过 docker 客户端来访问并控制你的 docker 守护进程来进行创建删除容器等操作。所以必须要开启加密认证或者在守护进程前面加上一个安全的代理。</p><blockquote><font color="#FF0000">注意：不要轻易开放远程访问，如果开放，一定要确认开放对象是可信赖的或者开启访问认证和加密传输。</font></blockquote><p>譬如，docker 服务器的内网 ip 是 10.0.0.1，外网 ip 是 45.57.36.48 ，使用 -H tcp://0.0.0.0:2375 来监听的 2375 端口，使用 -H tcp://45.57.36.48:2376 来监听 2376 端口，可以很方便的实现 2375 端口用于非加密访问，2376端口用于加密访问，然后通过防火墙规则限定 2375 端口对指定管理终端开放。</p><p>下面是一个简单的远程访问的例子：</p><p>两台服务器，都安装好 docker ，192.168.1.2 作为服务端开启远程访问。</p><p>服务端配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;hosts&quot;: [&quot;tcp://0.0.0.0:2375 &quot;,&quot;unix:///var/run/docker.sock&quot;,&quot;-H fd:// &quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新加载服务端配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> systemctl restart docker.service</span><br></pre></td></tr></table></figure><p>在客户端，有两种方式访问服务端的 docker 服务：</p><ul><li><p>通过 <a href="https://docs.docker.com/engine/api/v1.39/" target="_blank" rel="noopener">docker engine web api</a> 连接 server ，访问服务端的 info 接口。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl http://192.168.1.2:2375/info</span><br></pre></td></tr></table></figure></li><li><p>通过 docker 客户端命令访问服务端：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker -H tcp://192.168.1.2:2375 info</span><br></pre></td></tr></table></figure></li></ul><p>默认地，在客户端执行 docker 命令是连接本地的守护进程，可以修改 DOCKER_HOST 环境变量来改变默认连接：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export DOCKER_HOST="tcp://192.168.1.2:2375"</span><br></pre></td></tr></table></figure><p>通过将 DOCKER_HOST 置空来恢复本地连接：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export DOCKER_HOST=""</span><br></pre></td></tr></table></figure><h4 id="docker-命令"><a href="#docker-命令" class="headerlink" title="docker 命令"></a>docker 命令</h4><p>docker 命令主要是用来向服务端守护进程发送控制指令，来进行构建镜像，启动容器等一些列操作。它包括一系列子命令。每个子命令都有其单独的选项，查看 docker –help 来看命令概述，通过 docker COMMAND –help 来看子命令详细用法。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line">root@fengzhao-linux-server:~# docker --help</span><br><span class="line"></span><br><span class="line">Usage:  docker [OPTIONS] COMMAND</span><br><span class="line"></span><br><span class="line">A self-sufficient runtime for containers</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">      --config string      Location of client config files (default "/root/.docker")</span><br><span class="line">  -D, --debug              Enable debug mode</span><br><span class="line">  -H, --host list          Daemon socket(s) to connect to</span><br><span class="line">  -l, --log-level string   Set the logging level ("debug"|"info"|"warn"|"error"|"fatal") (default "info")</span><br><span class="line">      --tls                Use TLS; implied by --tlsverify</span><br><span class="line">      --tlscacert string   Trust certs signed only by this CA (default "/root/.docker/ca.pem")</span><br><span class="line">      --tlscert string     Path to TLS certificate file (default "/root/.docker/cert.pem")</span><br><span class="line">      --tlskey string      Path to TLS key file (default "/root/.docker/key.pem")</span><br><span class="line">      --tlsverify          Use TLS and verify the remote</span><br><span class="line">  -v, --version            Print version information and quit</span><br><span class="line"></span><br><span class="line">Management Commands:</span><br><span class="line">  config      Manage Docker configs</span><br><span class="line">  container   Manage containers</span><br><span class="line">  image       Manage images</span><br><span class="line">  network     Manage networks</span><br><span class="line">  node        Manage Swarm nodes</span><br><span class="line">  plugin      Manage plugins</span><br><span class="line">  secret      Manage Docker secrets</span><br><span class="line">  service     Manage services</span><br><span class="line">  stack       Manage Docker stacks</span><br><span class="line">  swarm       Manage Swarm</span><br><span class="line">  system      Manage Docker</span><br><span class="line">  trust       Manage trust on Docker images</span><br><span class="line">  volume      Manage volumes</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">  attach      Attach local standard input, output, and error streams to a running container</span><br><span class="line">  build       Build an image from a Dockerfile</span><br><span class="line">  commit      Create a new image from a container's changes</span><br><span class="line">  cp          Copy files/folders between a container and the local filesystem</span><br><span class="line">  create      Create a new container</span><br><span class="line">  diff        Inspect changes to files or directories on a container's filesystem</span><br><span class="line">  events      Get real time events from the server</span><br><span class="line">  exec        Run a command in a running container</span><br><span class="line">  export      Export a container's filesystem as a tar archive</span><br><span class="line">  history     Show the history of an image</span><br><span class="line">  images      List images</span><br><span class="line">  import      Import the contents from a tarball to create a filesystem image</span><br><span class="line">  info        Display system-wide information</span><br><span class="line">  inspect     Return low-level information on Docker objects</span><br><span class="line">  kill        Kill one or more running containers</span><br><span class="line">  load        Load an image from a tar archive or STDIN</span><br><span class="line">  login       Log in to a Docker registry</span><br><span class="line">  logout      Log out from a Docker registry</span><br><span class="line">  logs        Fetch the logs of a container</span><br><span class="line">  pause       Pause all processes within one or more containers</span><br><span class="line">  port        List port mappings or a specific mapping for the container</span><br><span class="line">  ps          List containers</span><br><span class="line">  pull        Pull an image or a repository from a registry</span><br><span class="line">  push        Push an image or a repository to a registry</span><br><span class="line">  rename      Rename a container</span><br><span class="line">  restart     Restart one or more containers</span><br><span class="line">  rm          Remove one or more containers</span><br><span class="line">  rmi         Remove one or more images</span><br><span class="line">  run         Run a command in a new container</span><br><span class="line">  save        Save one or more images to a tar archive (streamed to STDOUT by default)</span><br><span class="line">  search      Search the Docker Hub for images</span><br><span class="line">  start       Start one or more stopped containers</span><br><span class="line">  stats       Display a live stream of container(s) resource usage statistics</span><br><span class="line">  stop        Stop one or more running containers</span><br><span class="line">  tag         Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE</span><br><span class="line">  top         Display the running processes of a container</span><br><span class="line">  unpause     Unpause all processes within one or more containers</span><br><span class="line">  update      Update configuration of one or more containers</span><br><span class="line">  version     Show the Docker version information</span><br><span class="line">  wait        Block until one or more containers stop, then print their exit codes</span><br><span class="line"></span><br><span class="line">Run 'docker COMMAND --help' for more information on a command.</span><br><span class="line">root@fengzhao-linux-server:~#</span><br></pre></td></tr></table></figure><p>下面是一些常见的 docker 命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> docker --help  #查看帮助</span><br><span class="line"><span class="meta">$</span> docker version #查看版本</span><br><span class="line"><span class="meta">$</span> docker pull image #下载镜像</span><br><span class="line"><span class="meta">$</span> docker image ls # 列出所有镜像</span><br><span class="line"><span class="meta">$</span> docker run image #从镜像启动一个新的容器</span><br><span class="line"><span class="meta">$</span> docker ps  #查看运行中的容器，-a 查看所有容器</span><br></pre></td></tr></table></figure><h2 id="Docker-对象-1"><a href="#Docker-对象-1" class="headerlink" title="Docker 对象"></a>Docker 对象</h2><h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3><p>docker 镜像的概念，前面已经大致讲过，这里不再赘述，镜像的构建，一般会基于某个父镜像去构建。镜像的构建方法一般有三种方式：</p><ul><li>通过一个 Dockerfile 文件来描述镜像中的内容和操作，然后用 docker build 命令构建镜像。</li><li>启动一个容器后，在容器中通过一些基本操作做出改变后，用 docker commit 将容器提交为镜像。</li><li>按上述之一方式做好镜像后，推送到镜像仓库，下次使用时，可以直接从镜像仓库拉取到本地。</li></ul><p>举个例子，我们在一台新电脑上安装操作系统时，主要步骤是去微软官网下载 windows iso 镜像，然后刻录到U盘，然后去电脑上安装，然后自己去安装各种开发环境，和常用软件。我们可以在安装好软件后，通过工具创建镜像，这样下次通过自己制作的镜像安装操作系统，就会自带这些额外的软件，这就是第二种方式。但是有人认为制作镜像还是要手工安装软件比较麻烦。于是写了一个文件，里面包含安装开发环境和常用软件的指令，执行这个文件就会自动创建自己制作的镜像，这就是第一种方式，这个文件就是 Dockerfile。</p><p>通常，使用 Dockerfile 文件来构建镜像是比较多的做法。Dockerfile 中有一系列指令来构建镜像。</p><p>docker 镜像的命名空间主要是 Registry/Users/Repository/Tag，分别表示 Registry地址/用户空间/仓库名称/标签。</p><p>默认地的  Registry 是 dockerhub ，如果通过 docker image ls 查看到某个镜像没有 Registry ，那就是来自docker hub。</p><p>一些大型软件 在docker hub 上的镜像，都是由官方（docker 官方或软件发行官方）维护，在 <a href="https://hub.docker.com/" target="_blank" rel="noopener">docker hub</a>上搜索可以看到 official 字样，这类镜像，一般没有用户名称，或者其名称为 library 。</p><p>主要分为以下几种情况</p><ol><li>docker hub 上的官方镜像为默认Registry    ubuntu:16.04</li><li>docker hub 上用户空间下的镜像   fengzhao/nginx:latest</li><li>私有 docker registry上的镜像   hub.mycompany.com/dev/nginx:latest </li></ol><p>列出所有镜像：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">root@fengzhao-linux-server:~# docker image ls</span><br><span class="line">root@fengzhao-linux-server:~# docker image ls</span><br><span class="line">REPOSITORY                       TAG        IMAGE ID         CREATED             SIZE</span><br><span class="line">nginx                           latest      62f816a209e6     2 months ago        109MB</span><br><span class="line">hub.demo.com/fengzhao/nginx     latest      62f816a209e6     2 months ago        109MB</span><br><span class="line">chinafengzhao/nginx             v1.0        62f816a209e6     2 months ago        109MB</span><br><span class="line">root@fengzhao-linux-server:~#</span><br><span class="line">root@fengzhao-linux-server:~#</span><br><span class="line"><span class="meta">#</span> 这些，其实都是同一个镜像，只是不同的引用而已，因为他们</span><br><span class="line"><span class="meta">#</span> 第一个是官方的nginx镜像，</span><br><span class="line"><span class="meta">#</span> 第二个是给官方镜像打了新标签，可以通过 docker pull 推到自己本地的 docker Registry 中。</span><br><span class="line"><span class="meta">#</span> 第三个是给官方镜像打了用户空间（并带版本号），可以推到 dockerhub 中的 chinafengzhao 用户空间下。</span><br></pre></td></tr></table></figure><p>每个镜像，下载到当前服务器内，都有一个镜像 id来唯一标识这个镜像，我们可以给同一个镜像打多个标签，用来做镜像版本管理，使用 docker tag 命令来给镜像打标签：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> docker tag SOURCE_IMAGE[:TAG] TARGET_IMAGE[:TAG] #给镜像打一个标签 </span><br><span class="line"><span class="meta">$</span> docker  image rm Registry/Users/Repository/Tag   #移除某个标签，当最后一个时</span><br><span class="line"><span class="meta">#</span> 当某个镜像的Registry/Users/Repository/Tag均为空时，无法引用这个镜像，成为虚悬镜像。</span><br><span class="line"><span class="meta">#</span> 产生虚悬镜像的原因，从 Registry 拉取3.2版本的镜像，然后 Registry 重新制作3.2版本的镜像，然后你再＃拉这个镜像，这样最开始的那个3.2的镜像的REPOSITORY和TAG都被置空，无法引用</span><br><span class="line"><span class="meta">$</span> docker prune # 删除虚悬镜像</span><br><span class="line"><span class="meta">$</span> docker image ls -f dangling=true # 列出所有虚悬镜像</span><br></pre></td></tr></table></figure><h4 id="镜像管理常用命令"><a href="#镜像管理常用命令" class="headerlink" title="镜像管理常用命令"></a>镜像管理常用命令</h4><p>docker image COMMAND 是镜像管理的基本命令，可以通过帮助命令，逐层查看其所有的子命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">root@fengzhao-linux-server:~# docker image --help</span><br><span class="line"></span><br><span class="line">Usage:  docker image COMMAND</span><br><span class="line"></span><br><span class="line">Manage images</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">  build       Build an image from a Dockerfile</span><br><span class="line">  history     Show the history of an image</span><br><span class="line">  import      Import the contents from a tarball to create a filesystem image</span><br><span class="line">  inspect     Display detailed information on one or more images</span><br><span class="line">  load        Load an image from a tar archive or STDIN</span><br><span class="line">  ls          List images</span><br><span class="line">  prune       Remove unused images</span><br><span class="line">  pull        Pull an image or a repository from a registry</span><br><span class="line">  push        Push an image or a repository to a registry</span><br><span class="line">  rm          Remove one or more images</span><br><span class="line">  save        Save one or more images to a tar archive (streamed to STDOUT by default)</span><br><span class="line">  tag         Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE</span><br><span class="line"></span><br><span class="line">Run 'docker image COMMAND --help' for more information on a command.</span><br><span class="line">root@fengzhao-linux-server:~#</span><br></pre></td></tr></table></figure><p>下面仅列举一些常用的 docker 镜像管理命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> docker pull  Registry/Users/Repository/Tag # 从registry上拉取镜像，私有的可能需要docker login认证</span><br><span class="line"><span class="meta">$</span> docker image ls # 列出所有镜像</span><br><span class="line"><span class="meta">$</span> docker rmi  45fb1e3aa  # 删除这个id的镜像，参数可以是id，也可以是repoistry+tag，</span><br><span class="line"><span class="meta">$</span> docker tag busybox:latest  fengzhao/busybox:latest  # 给镜像添加额外的标签</span><br><span class="line"><span class="meta">$</span> docker</span><br></pre></td></tr></table></figure><h4 id="Dockerfile-构建镜像"><a href="#Dockerfile-构建镜像" class="headerlink" title="Dockerfile 构建镜像"></a>Dockerfile 构建镜像</h4><p>Dockerfile 是由一系列命令和参数构成的脚本文件，一个 Dockerfile 里面包含了构建整个 image 的完整命令。Docker 通过 docker build 执行 Dockerfile 中的一系列命令自动构建 image 。</p><p>通过 docker build 命令来从 Dockerfile 和下文中构建镜像，上下文一般就是 Dockerfile 文件所在的路径， 其中包含一系列制作镜像的所需的原文件，上下文可以在某个路径，或者是某个 URL （一般是git repo，不建议用 URL）中。上下文会被递归处理，所以路径下可以包含子目录。</p><p>Dockerfile 包含一系列指令，它必须以 FROM 作为第一行，表示基于某个父镜像构建。</p><p>构建过程是 docker daemon 来执行的，第一件事就是把整个上下文传给 daemon 。在多数情况下，创建一个空文件夹来存放 Dockerfile 和构建镜像所需的文件。把这个文件夹作为上下文。可以在任何位置执行 docker build 构建镜像，通过 -f 选项来指定 Dockerfile 文件。</p><blockquote><p><code>警告</code>：不要使用根目录<code>/</code>作为上下文，因为它会导致构建将硬盘中的所有内容传输到Docker守护进程。</p></blockquote><p>下面是一个 nginx 的 Dockerfile 文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span> /data/docker/nginx/Dockerfile</span><br><span class="line">FROM ubuntu:12.04</span><br><span class="line">MAINTAINER fengzhao &lt;fengzhao1124@hotmail.com&gt;</span><br><span class="line">RUN apt-get update</span><br><span class="line">RUN apt-get -y install nginx</span><br><span class="line"><span class="meta">#</span> put my local site to /var/www</span><br><span class="line">ADD index.html /var/www/html/</span><br><span class="line"><span class="meta">#</span> expose httpd port</span><br><span class="line">EXPOSE 80</span><br><span class="line"><span class="meta">#</span> the command to run</span><br><span class="line">CMD ["/usr/sbin/nginx"]</span><br></pre></td></tr></table></figure><p>通过 docker build 命令来构建镜像：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span> cd /data/docker/nginx/</span><br><span class="line"><span class="meta">$</span> docker build -t chinafengzhao/nginx:1.0.2 -t shykes/myapp:latest . </span><br><span class="line"><span class="meta">#</span> . 表示 Dockerfile 文件所在目录，当前构建的上下文。也可以用 -f /path/Dockerfile 来指定构建路径</span><br></pre></td></tr></table></figure><p>关于 docker build 命令的详细用法，可以查看帮助：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">root@fengzhao-linux-server:~#</span><br><span class="line">root@fengzhao-linux-server:~#</span><br><span class="line">root@fengzhao-linux-server:~# docker build --help</span><br><span class="line"></span><br><span class="line">Usage:  docker build [OPTIONS] PATH | URL | -</span><br><span class="line"></span><br><span class="line">Build an image from a Dockerfile</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">      --add-host list           Add a custom host-to-IP mapping (host:ip)</span><br><span class="line">      --build-arg list          Set build-time variables</span><br><span class="line">      --cache-from strings      Images to consider as cache sources</span><br><span class="line">      --cgroup-parent string    Optional parent cgroup for the container</span><br><span class="line">      --compress                Compress the build context using gzip</span><br><span class="line">      --cpu-period int          Limit the CPU CFS (Completely Fair Scheduler) period</span><br><span class="line">      --cpu-quota int           Limit the CPU CFS (Completely Fair Scheduler) quota</span><br><span class="line">  -c, --cpu-shares int          CPU shares (relative weight)</span><br><span class="line">      --cpuset-cpus string      CPUs in which to allow execution (0-3, 0,1)</span><br><span class="line">      --cpuset-mems string      MEMs in which to allow execution (0-3, 0,1)</span><br><span class="line">      --disable-content-trust   Skip image verification (default true)</span><br><span class="line">  -f, --file string             Name of the Dockerfile (Default is 'PATH/Dockerfile')</span><br><span class="line">      --force-rm                Always remove intermediate containers</span><br><span class="line">      --iidfile string          Write the image ID to the file</span><br><span class="line">      --isolation string        Container isolation technology</span><br><span class="line">      --label list              Set metadata for an image</span><br><span class="line">  -m, --memory bytes            Memory limit</span><br><span class="line">      --memory-swap bytes       Swap limit equal to memory plus swap: '-1' to enable unlimited swap</span><br><span class="line">      --network string          Set the networking mode for the RUN instructions during build (default "default")</span><br><span class="line">      --no-cache                Do not use cache when building the image</span><br><span class="line">      --pull                    Always attempt to pull a newer version of the image</span><br><span class="line">  -q, --quiet                   Suppress the build output and print image ID on success</span><br><span class="line">      --rm                      Remove intermediate containers after a successful build (default true)</span><br><span class="line">      --security-opt strings    Security options</span><br><span class="line">      --shm-size bytes          Size of /dev/shm</span><br><span class="line">  -t, --tag list                Name and optionally a tag in the 'name:tag' format</span><br><span class="line">      --target string           Set the target build stage to build.</span><br><span class="line">      --ulimit ulimit           Ulimit options (default [])</span><br><span class="line">root@fengzhao-linux-server:~#</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Docker-概述&quot;&gt;&lt;a href=&quot;#Docker-概述&quot; class=&quot;headerlink&quot; title=&quot;Docker 概述&quot;&gt;&lt;/a&gt;Docker 概述&lt;/h2&gt;&lt;p&gt;Docker是一个开发，运输和运行应用程序的开放平台。 Docker使您可以将应用程序与基础架构分离，以便快速交付软件。使用Docker，您可以像管理应用程序一样管理基础架构。通过利用Docker的方法快速发送，测试和部署代码，您可以显着减少编写代码和在生产中运行代码之间的延迟。&lt;/p&gt;
&lt;p&gt;Docker提供了在称为容器的松散隔离环境中打包和运行应用程序的功能。隔离和安全性允许您在给定主机上同时运行多个容器。容器是轻量级的，因为它们不需要管理程序的额外负载，而是直接在主机内核中运行。这意味着您可以在给定硬件组合上运行比使用虚拟机时更多的容器。您甚至可以在实际虚拟机的主机中运行Docker容器！&lt;/p&gt;
    
    </summary>
    
    
      <category term="docker" scheme="https://fengzhao.me/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>浅谈MySQL日志文件系统</title>
    <link href="https://fengzhao.me/2018/06/04/%E6%B5%85%E8%B0%88MySQL%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"/>
    <id>https://fengzhao.me/2018/06/04/浅谈MySQL日志文件系统/</id>
    <published>2018-06-04T03:47:26.000Z</published>
    <updated>2018-10-30T16:43:14.321Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MySQL日志文件系统"><a href="#MySQL日志文件系统" class="headerlink" title="MySQL日志文件系统"></a>MySQL日志文件系统</h1><p>日志是mysql数据库的重要组成部分。日志文件中记录着mysql数据库运行期间发生的变化；也就是说用来记录mysql数据库的客户端连接状况、SQL语句的执行情况和错误信息等。当数据库遭到意外的损坏时，可以通过日志查看文件出错的原因，并且可以通过日志文件进行数据恢复。</p><h1 id="MySQL日志分类"><a href="#MySQL日志分类" class="headerlink" title="MySQL日志分类"></a>MySQL日志分类</h1><p>MySQL日志大致可以分为一下几种类型：</p><a id="more"></a><table><thead><tr><th>日志类型</th><th>日志作用</th></tr></thead><tbody><tr><td>错误日志</td><td>记录启动、运行或停止mysqld时出现的问题。</td></tr><tr><td>通用查询日志</td><td>记录建立的客户端连接和执行的语句。</td></tr><tr><td>二进制日志</td><td>记录所有更改数据的语句。还用于复制。</td></tr><tr><td>中继日志</td><td>只有主从复制的slave服务器才会有，记录的是来自主服务器的数据变化；</td></tr><tr><td>慢查询日志</td><td>记录所有执行时间超过long_query_time秒的所有查询或不使用索引的查询。</td></tr><tr><td>DDL日志</td><td>也叫元数据日志，记录的是通过DDL进行的元数据操作；</td></tr></tbody></table><h1 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h1><p>MySQL的错误日志，默认是开启并无法关闭，一般存放在在数据目录中，以主机名.err格式命名，也可以用 可以用–log-error[=file_name]选项来开启mysql错误日志，该选项指定mysqld保存错误日志文件的位置。错误日志一般是文本文件，可以直接tail打开进行分析查看。</p><p>错误日志不仅仅记录着错误信息，它记录的事件有：</p><ul><li>服务器启动和关闭过程中的信息</li><li>服务器运行过程中的错误信息</li><li>事件调度器运行一个事件时产生的信息</li><li>(如果被配置为从服务器)启动从服务器进程时产生的信息</li></ul><p>查看错误日志存放路径：</p><pre>mysql> SHOW VARIABLES LIKE 'log_error%';+---------------+---------------------------------+| Variable_name | Value                           |+---------------+---------------------------------+| log_error     | /var/lib/mysql/iZ2319y43bmZ.err |+---------------+---------------------------------+1 row in set (0.00 sec)mysql> </pre><h1 id="通用查询日志"><a href="#通用查询日志" class="headerlink" title="通用查询日志"></a>通用查询日志</h1><p>通用查询日志记录了数据库执行的命令。而不仅仅只是select语句，当开启查询日志之后，数据库可能需要不停地写入查询日志，会增加很多磁盘I/O，所以除非是出于调试目的，一般不建议开启查询日志。</p><p>如果需要可以手动开启。如果开启了查询日志，可以通过如下3种方式输出在查询日志</p><ul><li>将查询日志存放于指定的日志文件中。</li><li>将查询日志存放于mysql.general_log表中。</li><li>将查询日志同时存放于指定的日志文件与mysql库的general_log表中。</li></ul><p>查看通用查询日志相关信息：</p><pre>mysql> show variables where variable_name like '%general_log%' or variable_name='log_output';+------------------+---------------------------------+| Variable_name    | Value                           |+------------------+---------------------------------+| general_log      | OFF                             || general_log_file | /var/lib/mysql/iZ2319y43bmZ.log || log_output       | FILE                            |+------------------+---------------------------------+3 rows in set (0.00 sec)</pre><p>log_oupt可以log_output:表示当查询日志开启以后，以哪种方式存放，log_output可以设置为4种值，FILE、TABLE 、FILE,TABLE、NONE。</p><p>此值为NONE时表示不记录查询日志，即使general_log设置为ON，如果log_output设置为NONE，也不会记录查询日志，其实，log_output不止控制用户查询日志的输出，慢查询日志的输出也是由此参数进行控制，也就是说，log_output设置为file，就表示查询日志和慢查询日志都存放到对应的文件中，设置为table，查询日志和慢查询日志就都存放在对应的数据库表中。</p><h1 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h1><p>MySQL慢查询日志是MySQL提供的一种日志记录，用来记录执行时长超过指定时长的查询语句，具体指运行时间超过 long_query_time 值的 SQL 语句，则会被记录到慢查询日志中。</p><p>long_query_time 默认值是 10 ，单位是 s，即默认是 10秒 。默认情况下，MySQL数据库并不会开启慢查询日志，需要手动设置这个参数。</p><p>慢查询日志开销比较小，通过对慢查询的分析可以到系统的性能问题，找到相关的sql语句并进一步优化，因为或多或少都有一些性能开销，所以如果不是为了调优，一般建议不用开启。</p><pre>mysql> SHOW VARIABLES LIKE 'slow_query_log%';+---------------------+--------------------------------------------------+| Variable_name       | Value                                            |+---------------------+--------------------------------------------------+| slow_query_log      | OFF                                              || slow_query_log_file | /usr/local/var/mysql/upstreamdeMac-mini-slow.log |+---------------------+--------------------------------------------------+</pre><h2 id="慢查询相关配置"><a href="#慢查询相关配置" class="headerlink" title="慢查询相关配置"></a>慢查询相关配置</h2><pre># slow loggingslow_query_log=1    //是否启用慢查询日志，[1 | 0] 或者 [ON | OFF]， MySQL 5.6以前此参数应该为log_slow_querieslog-output=FILE   // 指定用文件存储或者用数据表存储，与通用查询日志共用这个参数，日志记录到系统的专用日志表中，要比记录到文件耗费更多的系统资源，因此对于需要启用慢查询日志，又需要能够获得更高的系统性能，那么建议优先记录到文件。slow_query_log_file  //指定文件存储路径和文件名，一般在数据目录下，默认是/var/lib/mysql/hostname-slow.log。long_query_time=10    //慢查的时长单位为秒，可以精确到小数点后6位(微秒)。log_queries_not_using_indexes  //没有使用到索引的语句，是否被记录到慢查询日志中。log_timestamps      //主要是控制 error log、genera log，等等记录日志的显示时间参数,默认时间戳是utc时间，与北京时间相差8h，一般我们会设置成SYSTEMd为操作系统时间。</pre><h2 id="慢查询日志分析"><a href="#慢查询日志分析" class="headerlink" title="慢查询日志分析"></a>慢查询日志分析</h2><p>慢查询一般用下面两种工具来进行分析：</p><h3 id="mysqldumpslow"><a href="#mysqldumpslow" class="headerlink" title="mysqldumpslow"></a>mysqldumpslow</h3><p>mysqldumpslow是官方自带的慢查询日志分析工具，用perl编写，可以用mysqldumpslow -h来看看具体用法。</p><pre>[root@iZ2319y43bmZ ~]# mysqldumpslow  -hOption h requires an argumentERROR: bad optionUsage: mysqldumpslow [ OPTS... ] [ LOGS... ]Parse and summarize the MySQL slow query log. Options are  --verbose    verbose  --debug      debug  --help       write this text to standard output  -v           verbose  -d           debug  -s ORDER     what to sort by (al, at, ar, c, l, r, t), 'at' is default​                al: average lock time​                ar: average rows sent​                at: average query time​                 c: count​                 l: lock time​                 r: rows sent​                 t: query time    -r           reverse the sort order (largest last instead of first)  -t NUM       just show the top n queries  -a           don't abstract all numbers to N and strings to 'S'  -n NUM       abstract numbers with at least n digits within names  -g PATTERN   grep: only consider stmts that include this string  -h HOSTNAME  hostname of db server for *-slow.log filename (can be wildcard),​               default is '*', i.e. match all  -i NAME      name of server instance (if using mysql.server startup script)  -l           don't subtract lock time from total time[root@iZ2319y43bmZ ~]# </pre><p>主要参数：</p><ul><li>-v、–verbose : 在详细模式下运行，打印有关该程序的更多信息。</li><li>-d、–debug : 在调试模式下运行。</li><li>-s  [sort_type] : sort_type 是信息排序的依据<ul><li>al：average lock time，按平均等待锁的时间排序</li><li>ar：average rows sent，按平均发给客户端的行总数排序</li><li>at：average query time，按平均查询时间排序</li><li>c：count，按出现总次数排序</li><li>l：lock time，按等待锁的时间排序</li><li>r：rows sent，按扫描的行总数排序</li><li>t：query time，按累计总耗费时间排序</li></ul></li><li>-r ：倒序信息排序</li><li>-t NUM ：只显示 top n 条查询</li><li>-g PATTERN : 根据字符串筛选慢查询日志，可写正则匹配，大小写不敏感。</li><li>-h HOSTNAME : 根据服务器名称选择慢查询日志</li><li>-i NAME : 根据服务器 MySQL 实例名称选择慢查询日志</li><li>-l : 不要将总时间减去锁定时间</li></ul><p>​    </p><pre>[root@iZ2319y43bmZ mysql]# mysqldumpslow slowquery_2018052511.logReading mysql slow query log from slowquery_2018052511.logCount: 1  Time=1.23s (3s)  Lock=0.00s (0s)  Rows=143.0 (143), doyd[doyd]@[119.145.8.228]  show full tables from `kpzs_v2` where table_type = 'S'[root@iZ2319y43bmZ mysql]#  </pre><p>它主要统计慢查询语句的如下信息：</p><ul><li>出现次数(count)</li><li>执行最长时间，耗费总时间</li><li>等待锁的时间</li><li>发送给客户端的行数</li><li>执行该语句的客户端地址</li><li>执行的原语句</li></ul><h3 id="percona-toolkit"><a href="#percona-toolkit" class="headerlink" title="percona-toolkit"></a>percona-toolkit</h3><p>percona-toolkit 是一组高级命令行工具的集合，用prel语言编写，需要自行手工安装，安装可以参考<a href="https://www.percona.com/doc/percona-toolkit/LATEST/index.html" target="_blank" rel="noopener">官网文档</a>，用来执行各种通过手工执行非常复杂和麻烦的 mysql 和系统任务。percona-toolkit中关于慢查询，主要是pt-query-digest 这个工具，这个工具可以把分析结果输出到表中，做慢查询监控时，可以考虑写脚本去分析慢查询并将结果输出到监控库，设置脚本定期执行即可。如果想直接定位分析，一般pt-query-digest  slowquery_yyyymmddhh.log即可</p><p>用法：</p><pre>pt-query-digest [OPTIONS] [FILES] [DSN]</pre><p>参数说明：</p><ul><li>–create-review-table : 当使用–review参数把分析结果输出到表中时，如果没有表就自动创建。</li><li>–create-history-table : 当使用–history参数把分析结果输出到表中时，如果没有表就自动创建。</li><li>–filter : 对输入的慢查询按指定的字符串进行匹配过滤后再进行分析</li><li>–limit : 限制输出结果百分比或数量，默认值是20,即将最慢的20条语句输出，如果是50%则按总响应时间占比从大到小排序，输出到总和达到50%位置截止。</li><li>–host : mysql服务器地址</li><li>–user : mysql用户名</li><li>-password : mysql用户密码</li><li>–history : 将分析结果保存到表中，分析结果比较详细，下次再使用–history时，如果存在相同的语句，且查询所在的时间区间和历史表中的不同，则会记录到数据表中，可以通过查询同一CHECKSUM来比较某类型查询的历史变化。</li><li>–review : 将分析结果保存到表中，这个分析只是对查询条件进行参数化，一个类型的查询一条记录，比较简单。当下次使用–review时，如果存在相同的语句分析，就不会记录到数据表中。</li><li>–output : 分析结果输出类型，值可以是report(标准分析报告)、slowlog(Mysql slow log)、json、json-anon，一般使用report，以便于阅读。</li><li>–since : 从什么时间开始分析，值为字符串，可以是指定的某个 “yyyy-mm-dd [hh:mm:ss]” 格式的时间点，也可以是简单的一个时间值：s(秒)、h(小时)、m(分钟)、d(天)，如12h就表示从12小时前开始统计。<br>–until : 截止时间，配合—since可以分析一段时间内的慢查询。</li></ul><pre>[root@iZ2319y43bmZ mysql]# pt-query-digest  slowquery_2018060110.log# 240ms user time, 20ms system time, 24.45M rss, 204.81M vsz# Current date: Mon Jun  4 10:08:33 2018# Hostname: iZ2319y43bmZ# Files: slowquery_2018060110.log# Overall: 1 total, 1 unique, 0 QPS, 0x concurrency ______________________# Time range: all events occurred at 2018-06-01 10:49:59# Attribute          total     min     max     avg     95%  stddev  median# ============     ======= ======= ======= ======= ======= ======= =======# Exec time             1s      1s      1s      1s      1s       0      1s# Lock time           75us    75us    75us    75us    75us       0    75us# Rows sent            143     143     143     143     143       0     143# Rows examine         143     143     143     143     143       0     143# Query size            42      42      42      42      42       0      42# Profile# Rank Query ID           Response time Calls R/Call V/M   Item# ==== ================== ============= ===== ====== ===== ===========#    1 0xFBE0E38DA0F69470 1.0037 100.0%     1 1.0037  0.00 SHOW TABLES# Query 1: 0 QPS, 0x concurrency, ID 0xFBE0E38DA0F69470 at byte 0 ________# This item is included in the report because it matches --limit.# Scores: V/M = 0.00# Time range: all events occurred at 2018-06-01 10:49:59# Attribute    pct   total     min     max     avg     95%  stddev  median# ============ === ======= ======= ======= ======= ======= ======= =======# Count        100       1# Exec time    100      1s      1s      1s      1s      1s       0      1s# Lock time    100    75us    75us    75us    75us    75us       0    75us# Rows sent    100     143     143     143     143     143       0     143# Rows examine 100     143     143     143     143     143       0     143# Query size   100      42      42      42      42      42       0      42# String:# Databases    kpzs# Hosts        localhost# Users        doyd# Query_time distribution#   1us#  10us# 100us#   1ms#  10ms# 100ms#    1s  #################################################################  10s+# Tables#    SHOW TABLE STATUS FROM `kpzs` LIKE 'kpzs_v2'\G#    SHOW CREATE TABLE `kpzs`.`kpzs_v2`\GSHOW /*!50002 FULL*/ TABLES FROM `kpzs_v2`\G[root@iZ2319y43bmZ mysql]# </pre><h1 id="二进制日志文件"><a href="#二进制日志文件" class="headerlink" title="二进制日志文件"></a>二进制日志文件</h1><p>二进制日志（binlog）记录 MySQL 数据库中所有与更新相关的操作，即二进制日志记录了所有的 DDL（数据定义语言）语句和 DML（数据操纵语言）语句，但是不包括数据查询语句。常用于恢复数据库和主从复制。</p><h2 id="二进制日志作用"><a href="#二进制日志作用" class="headerlink" title="二进制日志作用"></a>二进制日志作用</h2><p>假如备份策略是每天0：00备份一次，那么在本次备份后，下面备份前的这个时间段内某一时刻，数据库崩溃，如果只是依靠备份文件来恢复，中间那段时间的数据就丢失了，所以还需要依靠二进制日志文件来对0：00之后的所有更新相关操作进行replay一次，这样就可以将数据恢复到崩溃时的状态，这与oracle中的归档日志是类似的。</p><h2 id="二进制日志类型"><a href="#二进制日志类型" class="headerlink" title="二进制日志类型"></a>二进制日志类型</h2><ul><li><p>statement模式：记录对数据库实例的更新语句，例如对语句update A set user=’test’，这种模式只记录该语句，这种模式的优点是日志量小，IO压力小，性能较高，缺点是记录的不够精确，例如，某些sql语句带了一些函数如user()，不同的数据库用户执行sql可能会操作不同的数据，这种情况下，只是记录语句是不够的，在恢复的时候，并不知道该语句当初是哪个用户执行的，所以并不能保证恢复与操作完全一致。</p></li><li><p>row模式：记录对语句所修改到的行，以及对行的具体修改，例如，update A set user=’test’，这条语句所影响到的行，以及修改，都会记录到二进制文件中，如果A表中有1000行数据，那么这一千行数据都会</p></li><li><p>mixed模式：在如下情况，系统会自动从statement模式切换刀片</p></li></ul><h2 id="查看二进制相关配置"><a href="#查看二进制相关配置" class="headerlink" title="查看二进制相关配置"></a>查看二进制相关配置</h2><pre>mysql> SHOW VARIABLES LIKE 'log_bin%';+---------------------------------+-------+| Variable_name                   | Value |+---------------------------------+-------+| log_bin                         | OFF   || log_bin_basename                |       || log_bin_index                   |       || log_bin_trust_function_creators | OFF   || log_bin_use_v1_row_events       | OFF   |+---------------------------------+-------+5 rows in set (0.04 sec)mysql> </pre><p>​    </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;MySQL日志文件系统&quot;&gt;&lt;a href=&quot;#MySQL日志文件系统&quot; class=&quot;headerlink&quot; title=&quot;MySQL日志文件系统&quot;&gt;&lt;/a&gt;MySQL日志文件系统&lt;/h1&gt;&lt;p&gt;日志是mysql数据库的重要组成部分。日志文件中记录着mysql数据库运行期间发生的变化；也就是说用来记录mysql数据库的客户端连接状况、SQL语句的执行情况和错误信息等。当数据库遭到意外的损坏时，可以通过日志查看文件出错的原因，并且可以通过日志文件进行数据恢复。&lt;/p&gt;
&lt;h1 id=&quot;MySQL日志分类&quot;&gt;&lt;a href=&quot;#MySQL日志分类&quot; class=&quot;headerlink&quot; title=&quot;MySQL日志分类&quot;&gt;&lt;/a&gt;MySQL日志分类&lt;/h1&gt;&lt;p&gt;MySQL日志大致可以分为一下几种类型：&lt;/p&gt;
    
    </summary>
    
    
      <category term="MySQL" scheme="https://fengzhao.me/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>理解数据库事务和锁</title>
    <link href="https://fengzhao.me/2018/05/10/DataBaseTransaction/"/>
    <id>https://fengzhao.me/2018/05/10/DataBaseTransaction/</id>
    <published>2018-05-10T03:39:47.000Z</published>
    <updated>2019-08-15T15:15:16.286Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h1><blockquote><p>数据库事务(Database Transaction)，一般是指要做的或所做的事情。在计算机术语中是指访问并可能更新数据库中各种数据项的一个程序执行单元(unit)。</p></blockquote><p>一个数据库事务通常包含了一个序列的对数据库的读/写操作。它的存在包含有以下两个目的：</p><blockquote><ul><li>为数据库操作序列提供了一个从失败中恢复到正常状态的方法，同时提供了数据库即使在异常状态下仍能保持一致性的方法。<br>当多个应用程序在并发访问数据库时，可以在这些应用程序之间提供一个隔离方法，以防止彼此的操作互相干扰。</li></ul></blockquote><blockquote><ul><li>当事务被提交给了DBMS（数据库管理系统），则DBMS（数据库管理系统）需要确保该事务中的所有操作都成功完成且其结果被永久保存在数据库中，如果事务中有的操作没有成功完成，则事务中的所有操作都需要被回滚，回到事务执行前的状态；同时，该事务对数据库或者其他事务的执行无影响，所有的事务都好像在独立的运行。</li></ul></blockquote><a id="more"></a><p>但在现实情况下，失败的风险很高。在一个数据库事务的执行过程中，有可能会遇上事务操作失败、数据库系统/操作系统失败，甚至是存储介质失败等情况。这便需要DBMS对一个执行失败的事务执行恢复操作，将其数据库状态恢复到一致状态（数据的一致性得到保证的状态）    。为了实现将数据库状态恢复到一致状态的功能，DBMS通常需要维护事务日志以追踪事务中所有影响数据库数据的操作。</p><h2 id="事务特性"><a href="#事务特性" class="headerlink" title="事务特性"></a>事务特性</h2><p>并非任意的对数据库的操作序列都是数据库事务。数据库事务拥有以下四个特性，习惯上被称之为ACID特性。</p><blockquote><ul><li>原子性（Atomicity）：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行。</li><li>一致性（Consistency）：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束。</li><li>隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行。</li><li>持久性（Durability）：已被提交的事务对数据库的修改应该永久保存在数据库中。</li></ul></blockquote><h2 id="事务举例"><a href="#事务举例" class="headerlink" title="事务举例"></a>事务举例</h2><p>用一个常用的“A账户向B账号汇钱”的例子来说明如何通过数据库事务保证数据的准确性和完整性。熟悉关系型数据库事务的都知道从帐号A到帐号B需要6个操作：</p><p>1、从A账号中把余额读出来（500）。<br><br>2、对A账号做减法操作（500-100）。<br><br>3、把结果写回A账号中（400）。<br><br>4、从B账号中把余额读出来（500）。<br><br>5、对B账号做加法操作（500+100）。<br><br>6、把结果写回B账号中（600）。<br></p><h3 id="原子性："><a href="#原子性：" class="headerlink" title="原子性："></a>原子性：</h3><p>保证1-6所有过程要么都执行，要么都不执行。一旦在执行某一步骤的过程中发生问题，就需要执行回滚操作。 假如执行到第五步的时候，B账户突然不可用（比如被注销），那么之前的所有操作都应该回滚到执行事务之前的状态。</p><h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><p>在转账之前，A和B的账户中共有500+500=1000元钱。在转账之后，A和B的账户中共有400+600=1000元。也就是说，数据的状态在执行该事务操作之后从一个状态改变到了另外一个状态。同时一致性还能保证账户余额不会变成负数等。</p><h3 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h3><p>在A向B转账的整个过程中，只要事务还没有提交（commit），查询A账户和B账户的时候，两个账户里面的钱的数量都不会有变化。<br>如果在A给B转账的同时，有另外一个事务执行了C给B转账的操作，那么当两个事务都结束的时候，B账户里面的钱应该是A转给B的钱加上C转给B的钱再加上自己原有的钱。</p><h3 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h3><p>一旦转账成功（事务提交），两个账户的里面的钱就会真的发生变化（会把数据写入数据库做持久化保存）。</p><h1 id="数据库读现象"><a href="#数据库读现象" class="headerlink" title="数据库读现象"></a>数据库读现象</h1><p>“读现象”是多个事务并发执行时，在读取数据方面可能碰到的状况。先了解它们有助于理解各隔离级别的含义。其中包括脏读、不可重复读和幻读。</p><h2 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h2><p>脏读是指在数据库访问中，当一个事务A正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务B也访问这个数据，然后使用了这个数据。然后A又进行回滚操作，则事务B访问的数据是无效的。即上述转账例子中，转账事务进行到一半的时候，此时另外一个事务去读了A账号的余额，然后转账事务回滚，A的余额变回以前的值。此时后面读余额的事务即为脏读。</p><h2 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h2><p>不可重复读，即在一个事务中分多次读同一数据，但是在前后两次读取之间,另外一个事务也在访问该数据，可能进行了修改，这样就造成了第一次事务的前后两次读取的数据不一致的现象。例如，一个编辑人员两次读取同一文档，但在两次读取之间，作者重写了该文档。当编辑人员第二次读取文档时，文档已更改。原始读取不可重复。如果只有在作者全部完成编写后编辑人员才可以读取文档，则可以避免该问题。</p><h2 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h2><p>幻读与不可重复读之间很容易让人混淆。举一个简单的例子来理解一下幻读：<br></p><p>users： id 主键</p><p>1、事务A：select * from users where id = 1;<br><br>2、事务B：insert into <code>users</code>(<code>id</code>, <code>name</code>) values (1, ‘big cat’);<br><br>3、事务A：insert into <code>users</code>(<code>id</code>, <code>name</code>) values (1, ‘big cat’);<br></p><blockquote><p>A ：主事务，检测表中是否有 id 为 1 的记录，没有则插入，这是我们期望的正常业务逻辑。<br>B ：干扰事务，目的在于扰乱 T1 的正常的事务执行。<br></p></blockquote><p>关于这种现象，可以称之为幻读。在mysql中，关于这两个事务，可能会有两个结果，A全部B失败，或者B成功A失败。这取决于数据库的不同隔离级别。</p><p>例如，在 RR 隔离级别下，1、2是正常执行的，3则会报主键冲突，对于A事务的业务是执行失败的，这里事务A就发生了幻读，因为它读取的数据状态不能满足它的下一步业务。</p><h1 id="数据库并发控制"><a href="#数据库并发控制" class="headerlink" title="数据库并发控制"></a>数据库并发控制</h1><h2 id="并发控制"><a href="#并发控制" class="headerlink" title="并发控制"></a>并发控制</h2><blockquote><p> 在计算机科学，特别是程序设计、操作系统、多处理机和数据库等领域，并发控制（Concurrency control）是确保及时纠正由并发操作导致的错误的一种机制。</p></blockquote><p>我们都知道事务的几种性质，数据库为了维护这些性质，尤其是一致性和隔离性，一般使用加锁这种方式。同时数据库又是个高并发的应用，同一时间会有大量的并发访问，如果加锁过度，会极大的降低并发处理能力。所以对于加锁的处理，可以说就是数据库对于事务处理的精髓所在。</p><p>数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。前面关于事务的概念以及读现象举的例子其实都是并发的场景。再举例讨论一个实际场景中的例子：两个火车票代售点，同时读取12306数据库中的某趟列车的车票数量为X，然后同时卖出一张票，然后同时提交了X-1到数据库中，这样就造成了卖了两张票，而库中记录只减了一张。生这种情况的原因是因为两个事务读入同一数据并同时修改，其中一个事务提交的结果破坏了另一个事务提交的结果，导致其数据的修改被丢失，破坏了事务的隔离性。并发控制要解决的就是这类问题。</p><h2 id="数据库隔离"><a href="#数据库隔离" class="headerlink" title="数据库隔离"></a>数据库隔离</h2><p>在DBMS中，事务保证了一个操作序列可以全部都执行或者全部都不执行（原子性），从一个状态转变到另外一个状态（一致性）。由于事务满足久性。所以一旦事务被提交之后，数据就能够被持久化下来，又因为事务是满足隔离性的，所以，当多个事务同时处理同一个数据的时候，多个事务直接是互不影响的，所以，在多个事务并发操作的过程中，如果控制不好隔离级别，就有可能产生脏读、不可重复读或者幻读等读现象。</p><p>ANSI/ISO SQL定义的标准隔离级别有四种，从高到底依次为：可序列化(Serializable)、可重复读(Repeatable reads)、提交读(Read committed)、未提交读(Read uncommitted)。<br></p><table><thead><tr><th style="text-align:left">隔离级别</th><th style="text-align:left">脏读（Dirty Read）</th><th style="text-align:left">不可重复读（NonRepeatable Read）</th><th style="text-align:left">幻读（Phantom Read）</th></tr></thead><tbody><tr><td style="text-align:left">未提交读（Read uncommitted）</td><td style="text-align:left">可能</td><td style="text-align:left">可能</td><td style="text-align:left">可能</td></tr><tr><td style="text-align:left">已提交读（Read committed）</td><td style="text-align:left">不可能</td><td style="text-align:left">可能</td><td style="text-align:left">可能</td></tr><tr><td style="text-align:left">可重复读（Repeatable read）</td><td style="text-align:left">不可能</td><td style="text-align:left">不可能</td><td style="text-align:left">可能</td></tr><tr><td style="text-align:left">可串行化（Serializable ）</td><td style="text-align:left">不可能</td><td style="text-align:left">不可能</td><td style="text-align:left">不可能     </td></tr></tbody></table><blockquote><ul><li>未提交读(Read Uncommitted)：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据</li><li>提交读(Read Committed)：只能读取到已经提交的数据。Oracle等多数数据库默认都是该级别 (不重复读)</li><li>可重复读(Repeated Read)：可重复读。在同一个事务内的查询都是事务开始时刻一致的，InnoDB默认级别。 在SQL标准中，该隔离级别消除了不可重复读，但是还存在幻象读</li><li>串行读(Serializable)：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞</li></ul></blockquote><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><p>当并发事务同时访问一个资源时，有可能导致数据不一致，因此需要一种机制来将数据访问顺序化，以保证数据库数据的一致性。锁就是其中的一种机制。可以简单理解为当某个事务在操作开始时，锁定某一个对象，在这个事务操作结束之前，不允许其他事务操作这个对象。下面是常见的锁分类：</p><h3 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h3><p>1、按照锁定的对象的粒度划分：表级锁、行级锁、页级锁（mysql）<br><br>2、按锁级别划分：共享锁（shared lock，读锁，shared lock）、排他锁（exclusive lock，写锁，write lock）<br><br>3、按使用方式划分，可分为乐观锁、悲观锁<br></p><p>各种锁的比较：</p><blockquote><ul><li>表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。</li><li>行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。</li><li>页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。</li></ul></blockquote><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote><p>淘宝MySQL博客 <a href="http://mysql.taobao.org/monthly/2016/01/01/" target="_blank" rel="noopener">http://mysql.taobao.org/monthly/2016/01/01/</a> <br><br>美团点评技术团队 <a href="https://tech.meituan.com/innodb-lock.html" target="_blank" rel="noopener">https://tech.meituan.com/innodb-lock.html</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数据库事务&quot;&gt;&lt;a href=&quot;#数据库事务&quot; class=&quot;headerlink&quot; title=&quot;数据库事务&quot;&gt;&lt;/a&gt;数据库事务&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;数据库事务(Database Transaction)，一般是指要做的或所做的事情。在计算机术语中是指访问并可能更新数据库中各种数据项的一个程序执行单元(unit)。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一个数据库事务通常包含了一个序列的对数据库的读/写操作。它的存在包含有以下两个目的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;为数据库操作序列提供了一个从失败中恢复到正常状态的方法，同时提供了数据库即使在异常状态下仍能保持一致性的方法。&lt;br&gt;当多个应用程序在并发访问数据库时，可以在这些应用程序之间提供一个隔离方法，以防止彼此的操作互相干扰。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;当事务被提交给了DBMS（数据库管理系统），则DBMS（数据库管理系统）需要确保该事务中的所有操作都成功完成且其结果被永久保存在数据库中，如果事务中有的操作没有成功完成，则事务中的所有操作都需要被回滚，回到事务执行前的状态；同时，该事务对数据库或者其他事务的执行无影响，所有的事务都好像在独立的运行。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="https://fengzhao.me/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Java注解</title>
    <link href="https://fengzhao.me/2017/11/12/annotation/"/>
    <id>https://fengzhao.me/2017/11/12/annotation/</id>
    <published>2017-11-12T06:41:00.000Z</published>
    <updated>2018-05-08T12:25:29.835Z</updated>
    
    <content type="html"><![CDATA[<p>记录Java注解的学习过程，通过自己的语言描述我对注解的认识。<br><a id="more"></a></p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>很多文章都把注解定义为元数据，它提供程序数据，但不是作为程序本身的组成部分，注解不会直接影响他们所注解的代码的行为。实际上，他们是用来修饰代码的，Java语言中的类、方法、变量、参数和包等都可以被注解标注。和Javadoc不同，Java注解可以通过反射获取标注内容。在编译器生成类文件时，标注可以被嵌入到字节码中。Java虚拟机可以保留注解内容，在运行时可以获取到注解内容。当然它也支持自定义Java注解。</p><h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><p>元注解实际上就是修饰注解的注解，他们是专门在定义注解的时候使用，在java.lang.annotation中定义，负责标注其他注解的一些属性，分别是：</p><ul><li>Retention   标记当前注解的生命周期</li><li>Target  标记当前注解应该可以标记哪种Java成员。</li><li>Documented  标记这些注解是否包含在用户文档中。  </li><li>Inherited  标记这个注解是继承于哪个注解类(默认 注解并没有继承于任何子类)</li><li>Repeatable  Java 8 开始支持，标识某注解可以在同一个声明上使用多次。</li></ul><h3 id="Retention注解"><a href="#Retention注解" class="headerlink" title="Retention注解"></a>Retention注解</h3><p>Retention注解标注当前Annotation被保留的时间长短：某些注解仅出现在源代码中，而被编译器丢弃；而另一些却被编译在class文件中；编译在class文件中的Annotation可能会被虚拟机忽略，而另一些在class被装载时将被读取（请注意并不影响class的执行，因为Annotation与class在使用上是被分离的）。使用这个meta-Annotation可以对 Annotation的“生命周期”限制。</p><p>取值范围：取值（RetentionPoicy）有：</p><ul><li>SOURCE:被标注的注解只保留到源码级，会被编译器忽略</li><li>CLASS:被标注的注解在编译时会被编译器识别，但会被Java虚拟机忽略。</li><li>RUNTIME:被标注的注解会被Java虚拟机识别，因此可用于运行时环境。</li></ul><h3 id="Target注解"><a href="#Target注解" class="headerlink" title="Target注解"></a>Target注解</h3><p>Target注解限制了其注解的注解可用于其他哪些Java元素，目标注解指定以下元素类型作为其值：</p><ul><li>ANNOTATION_TYPE    注解类型声明</li><li>CONSTRUCTOR    构造方法声明</li><li>FIELD    字段声明（包括枚举常量）</li><li>LOCAL_VARIABLE    局部变量声明</li><li>METHOD    方法声明</li><li>PACKAGE    包声明</li><li>PARAMETER    参数声明</li><li>TYPE    类、接口（包括注解类型）或枚举声明</li></ul><h3 id="Documented注解"><a href="#Documented注解" class="headerlink" title="Documented注解"></a>Documented注解</h3><p>Document注解表示只要它制定的注解的元素都应该用Javadoc工具文档化。</p><h3 id="Repeatable注解"><a href="#Repeatable注解" class="headerlink" title="Repeatable注解"></a>Repeatable注解</h3><p>Repeatable注解过的注解可多次用于同一个声明或类声明。</p><h2 id="注解实例"><a href="#注解实例" class="headerlink" title="注解实例"></a>注解实例</h2><p>看了这么多概念，下面上代码来理解一下。</p><h3 id="声明注解"><a href="#声明注解" class="headerlink" title="声明注解"></a>声明注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.ANNOTATION_TYPE,ElementType.METHOD,ElementType.TYPE,ElementType.FIELD&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AnnotationTest &#123;</span><br><span class="line">    <span class="function">String <span class="title">author</span><span class="params">()</span> <span class="keyword">default</span> "fengzhao"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">age</span><span class="params">()</span><span class="keyword">default</span> 18</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码声明了一个AnnotationTest注解，限定了注解的声明周期与使用范围，声明注解与普通接口类似，在interface关键字前加上@符号就可以声明注解。这个注解有两个属性:autor和age,且设置了默认值。</p><h3 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AnnotationTest</span>(author = <span class="string">"fengzhaoadmin"</span>, age=<span class="number">13</span> )</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationUse</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AnnotationTest</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">classAnnotationTEST</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Class cl =AnnotationUse.class;</span><br><span class="line">        <span class="keyword">if</span>(cl.isAnnotationPresent(AnnotationTest.class))&#123;</span><br><span class="line">            AnnotationTest at =(AnnotationTest) cl.getAnnotation(AnnotationTest.class);</span><br><span class="line">            System.out.print(at.author());  <span class="comment">//打印fengzhaoadmin</span></span><br><span class="line">            System.out.print(at.age()); <span class="comment">//打印13</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.print(<span class="string">"this class isn't annotationed by AnnotationTest "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodAnnotationTEST</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class cl =AnnotationUse.class;</span><br><span class="line">            Method method = cl.getDeclaredMethod(<span class="string">"classAnnotationTEST"</span>,(Class [])<span class="keyword">null</span> );</span><br><span class="line">            method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">          AnnotationTest at=(AnnotationTest)  method.getAnnotation(AnnotationTest.class);</span><br><span class="line">            System.out.print(at.author());</span><br><span class="line">            System.out.print(at.age());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (NoSuchMethodException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []argss)</span></span>&#123;</span><br><span class="line">        classAnnotationTEST();</span><br><span class="line">        methodAnnotationTEST();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在代码中，使用AnnotationTest去注解类，并设置其注解属性，在classAnnotationTEST中通过反射，打印其注解。继续使用该注解去注解classAnnotationTEST方法，在methodAnnotationTEST中通过反射，打印classAnnotationTEST方法的注解。</p><h2 id="内置注解"><a href="#内置注解" class="headerlink" title="内置注解"></a>内置注解</h2><p>Java已经内置了一些注解，我们平时经常会见到这些注解。</p><h3 id="Deprecated"><a href="#Deprecated" class="headerlink" title="Deprecated"></a>Deprecated</h3><p>这个注解是用来标记过时的元素，想必大家在日常开发中经常碰到。编译器在编译阶段遇到这个注解时会发出提醒警告，告诉开发者正在调用一个过时的元素比如过时的方法、过时的类、过时的成员变量。使用idea自动补全方法的时候，经常会看到一些方法被加上横线，这就是说明该方法已经被废弃了。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eating</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"Eating"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drinking</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"Dinking"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ide中调用Eating方法的时候，就会提示该方法被弃用。</p><h3 id="Ovveride"><a href="#Ovveride" class="headerlink" title="Ovveride"></a>Ovveride</h3><p>这个注解的作用是标识某一个方法是否覆盖了它的父类的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">displayName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"水果的名字是：*****"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">displayName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"水果的名字是：桔子"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">displayname</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"水果的名字是：苹果"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Orange类编译不会有问题，Apple类在编译的时候，就会提示相关错误。</p><h2 id="SuppressWarnings"><a href="#SuppressWarnings" class="headerlink" title="SuppressWarnings"></a>SuppressWarnings</h2><p>SuppressWarnings用来抑制编译器生成警告信息。可以修饰的元素为类，方法，方法参数，属性，局部变量，例如在泛型中使用原生数据类型。<br>它的定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SuppressWarnings &#123;</span><br><span class="line">    String[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该注解有方法value(）,可支持多个字符串参数，使用方法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SupressWarning</span>(value=&#123;<span class="string">"uncheck"</span>,<span class="string">"deprecation"</span>&#125;).</span><br></pre></td></tr></table></figure></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote><p> <a href="http://www.importnew.com/10294.html" target="_blank" rel="noopener">http://www.importnew.com/10294.html</a><br><a href="http://blog.csdn.net/briblue/article/details/73824058" target="_blank" rel="noopener">http://blog.csdn.net/briblue/article/details/73824058</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;记录Java注解的学习过程，通过自己的语言描述我对注解的认识。&lt;br&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://fengzhao.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java类型信息和反射</title>
    <link href="https://fengzhao.me/2017/11/12/javat-ype/"/>
    <id>https://fengzhao.me/2017/11/12/javat-ype/</id>
    <published>2017-11-12T06:41:00.000Z</published>
    <updated>2018-05-08T12:24:51.627Z</updated>
    
    <content type="html"><![CDATA[<p>Java中最常见的反射及关键类和方法的应用。</p><a id="more"></a><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>运行时类型信息（run time type information），可以使得你在程序运行时发现和使用类型信息。在java中主要有两种方式，一种是传统的RTTI，一种是反射机制，它允许在运行时发现和使用类的信息。</p><h2 id="Class对象"><a href="#Class对象" class="headerlink" title="Class对象"></a>Class对象</h2><p>jdk中有一个java.lang.Class<t>的类，这个类的实例代表着java运行时中的类和接口，通过这个类，我们可以在运行时发现和使用类型信息，获取类有三种方式：</t></p><h3 id="类字面常量"><a href="#类字面常量" class="headerlink" title="类字面常量"></a>类字面常量</h3><p>在没有类的实例引用时，可以通过类字面常量的方式来获取这个类的Class对象，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> me.fengzhao.typeinfo;</span><br><span class="line"><span class="keyword">import</span> java.lang.Class ;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span></span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassTest</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Class cl = Dog.class;</span><br><span class="line">        System.out.print(cl.getTypeName())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这段代码将会打印出这个类的完全限定名，通过类名.class这种方法，获取这个类的class对象，通过这个代码，也可以看到class对象用</p><p>### </p><h3 id="Retention注解"><a href="#Retention注解" class="headerlink" title="Retention注解"></a>Retention注解</h3><p>Retention注解标注当前Annotation被保留的时间长短：某些注解仅出现在源代码中，而被编译器丢弃；而另一些却被编译在class文件中；编译在class文件中的Annotation可能会被虚拟机忽略，而另一些在class被装载时将被读取（请注意并不影响class的执行，因为Annotation与class在使用上是被分离的）。使用这个meta-Annotation可以对 Annotation的“生命周期”限制。</p><p>取值范围：取值（RetentionPoicy）有：</p><ul><li>SOURCE:被标注的注解只保留到源码级，会被编译器忽略</li><li>CLASS:被标注的注解在编译时会被编译器识别，但会被Java虚拟机忽略。</li><li>RUNTIME:被标注的注解会被Java虚拟机识别，因此可用于运行时环境。</li></ul><h3 id="Target注解"><a href="#Target注解" class="headerlink" title="Target注解"></a>Target注解</h3><p>Target注解限制了其注解的注解可用于其他哪些Java元素，目标注解指定以下元素类型作为其值：</p><ul><li>ANNOTATION_TYPE    注解类型声明</li><li>CONSTRUCTOR    构造方法声明</li><li>FIELD    字段声明（包括枚举常量）</li><li>LOCAL_VARIABLE    局部变量声明</li><li>METHOD    方法声明</li><li>PACKAGE    包声明</li><li>PARAMETER    参数声明</li><li>TYPE    类、接口（包括注解类型）或枚举声明</li></ul><h3 id="Documented注解"><a href="#Documented注解" class="headerlink" title="Documented注解"></a>Documented注解</h3><p>Document注解表示只要它制定的注解的元素都应该用Javadoc工具文档化。</p><h3 id="Repeatable注解"><a href="#Repeatable注解" class="headerlink" title="Repeatable注解"></a>Repeatable注解</h3><p>Repeatable注解过的注解可多次用于同一个声明或类声明。</p><h2 id="注解实例"><a href="#注解实例" class="headerlink" title="注解实例"></a>注解实例</h2><p>看了这么多概念，下面上代码来理解一下。</p><h3 id="声明注解"><a href="#声明注解" class="headerlink" title="声明注解"></a>声明注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.ANNOTATION_TYPE,ElementType.METHOD,ElementType.TYPE,ElementType.FIELD&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AnnotationTest &#123;</span><br><span class="line">    <span class="function">String <span class="title">author</span><span class="params">()</span> <span class="keyword">default</span> "fengzhao"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">age</span><span class="params">()</span><span class="keyword">default</span> 18</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码声明了一个AnnotationTest注解，限定了注解的声明周期与使用范围，声明注解与普通接口类似，在interface关键字前加上@符号就可以声明注解。这个注解有两个属性:autor和age,且设置了默认值。</p><h3 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AnnotationTest</span>(author = <span class="string">"fengzhaoadmin"</span>, age=<span class="number">13</span> )</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationUse</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AnnotationTest</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">classAnnotationTEST</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Class cl =AnnotationUse.class;</span><br><span class="line">        <span class="keyword">if</span>(cl.isAnnotationPresent(AnnotationTest.class))&#123;</span><br><span class="line">            AnnotationTest at =(AnnotationTest) cl.getAnnotation(AnnotationTest.class);</span><br><span class="line">            System.out.print(at.author());  <span class="comment">//打印fengzhaoadmin</span></span><br><span class="line">            System.out.print(at.age()); <span class="comment">//打印13</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.print(<span class="string">"this class isn't annotationed by AnnotationTest "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodAnnotationTEST</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class cl =AnnotationUse.class;</span><br><span class="line">            Method method = cl.getDeclaredMethod(<span class="string">"classAnnotationTEST"</span>,(Class [])<span class="keyword">null</span> );</span><br><span class="line">            method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">          AnnotationTest at=(AnnotationTest)  method.getAnnotation(AnnotationTest.class);</span><br><span class="line">            System.out.print(at.author());</span><br><span class="line">            System.out.print(at.age());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (NoSuchMethodException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            System.out.println(e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">main</span><span class="params">(String []argss)</span></span>&#123;</span><br><span class="line">        classAnnotationTEST();</span><br><span class="line">        methodAnnotationTEST();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在代码中，使用AnnotationTest去注解类，并设置其注解属性，在classAnnotationTEST中通过反射，打印其注解。继续使用该注解去注解classAnnotationTEST方法，在methodAnnotationTEST中通过反射，打印classAnnotationTEST方法的注解。</p><h2 id="内置注解"><a href="#内置注解" class="headerlink" title="内置注解"></a>内置注解</h2><p>Java已经内置了一些注解，我们平时经常会见到这些注解。</p><h3 id="Deprecated"><a href="#Deprecated" class="headerlink" title="Deprecated"></a>Deprecated</h3><p>这个注解是用来标记过时的元素，想必大家在日常开发中经常碰到。编译器在编译阶段遇到这个注解时会发出提醒警告，告诉开发者正在调用一个过时的元素比如过时的方法、过时的类、过时的成员变量。使用idea自动补全方法的时候，经常会看到一些方法被加上横线，这就是说明该方法已经被废弃了。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eating</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"Eating"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">drinking</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.print(<span class="string">"Dinking"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在ide中调用Eating方法的时候，就会提示该方法被弃用。</p><h3 id="Ovveride"><a href="#Ovveride" class="headerlink" title="Ovveride"></a>Ovveride</h3><p>这个注解的作用是标识某一个方法是否覆盖了它的父类的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">displayName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"水果的名字是：*****"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Orange</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">displayName</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"水果的名字是：桔子"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">displayname</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"水果的名字是：苹果"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Orange类编译不会有问题，Apple类在编译的时候，就会提示相关错误。</p><h2 id="SuppressWarnings"><a href="#SuppressWarnings" class="headerlink" title="SuppressWarnings"></a>SuppressWarnings</h2><p>SuppressWarnings用来抑制编译器生成警告信息。可以修饰的元素为类，方法，方法参数，属性，局部变量，例如在泛型中使用原生数据类型。<br>它的定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SuppressWarnings &#123;</span><br><span class="line">    String[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该注解有方法value(）,可支持多个字符串参数，使用方法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SupressWarning</span>(value=&#123;<span class="string">"uncheck"</span>,<span class="string">"deprecation"</span>&#125;).</span><br></pre></td></tr></table></figure></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><blockquote><p> <a href="http://www.importnew.com/10294.html" target="_blank" rel="noopener">http://www.importnew.com/10294.html</a><br><a href="http://blog.csdn.net/briblue/article/details/73824058" target="_blank" rel="noopener">http://blog.csdn.net/briblue/article/details/73824058</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Java中最常见的反射及关键类和方法的应用。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://fengzhao.me/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Python特殊方法</title>
    <link href="https://fengzhao.me/2017/05/07/python-special-method/"/>
    <id>https://fengzhao.me/2017/05/07/python-special-method/</id>
    <published>2017-05-07T06:00:00.000Z</published>
    <updated>2018-05-08T12:27:00.271Z</updated>
    
    <content type="html"><![CDATA[<p>Python一切皆对象，但同时，Python还是一个多范式语言(multi-paradigm),你不仅可以使用面向对象的方式来编写程序，还可以用面向过程的方式来编写相同功能的程序(还有函数式、声明式等，我们暂不深入)。Python的多范式依赖于Python对象中的特殊方法(special method)。</p><a id="more"></a><p>特殊方法名的前后各有两个下划线。特殊方法又被成为魔法方法(magic method)，定义了许多Python语法和表达方式，正如我们在下面的例子中将要看到的。当对象中定义了特殊方法的时候，Python也会对它们有“特殊优待”。比如定义了__init__()方法的类，会在创建对象的时候自动执行__init__()方法中的操作。</p><p>可以通过dir()来查看对象所拥有的特殊方法，比如dir(1),我们把1看作是一个整数类的实例，执行dir(1)就是查看1这个整数对象拥有的特殊方法。</p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>  Python中的运算符是通过调用对象的特殊方法来实现的，举一个最常见的例子1+1，实际上是调用1这个对象的__add__()方法。</p><p>  比如：</p><pre><code>&apos;abc&apos; + &apos;xyz&apos;        # 连接字符串</code></pre><p>   实际上是执行了下述操作：</p><pre><code>&apos;abc.__add__(&apos;xyz&apos;)&apos;</code></pre><p>  所以在python中看两个对象能否进行加法运算，首先要看相应的对象是否有__add__()方法。一旦对象有__add__()方法,即使这个对象从数学上来说不可加，但是我们仍然可以用加法的形式（+运算符）来表达object.__add__()方法，这有点类似C#中的运算符重载，在Python中，运算符起到简化书写的功能，但它依靠特殊方法实现。</p><p>  Python不强制用户使用面向对象的编程方法。用户可以选择自己喜欢的使用方式(比如选择使用+符号，还是使用更加面向对象的__add__()方法)。特殊方法写起来总是要更费事一点。</p><p>  尝试下面的操作，看看效果，在想想这些对象的方法对应的运算符。</p><pre><code>（1.8).__mul__(2.0)（True.__or__(False)</code></pre><h2 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h2><p>与运算符类似，python的内置函数也是调用对象的特殊方法，比如：</p><pre><code>abs(-1)                # 求绝对值</code></pre><p>  实际上是执行了下述操作：</p><pre><code>(-1).__abs__()         # 调用-1这个对象的特殊方法来求绝对值。</code></pre><p>  相对于去调用对象特殊方法，直接使用内置函数显的更加短小简洁，当然，可能看起来没有调用对象的特殊方法那么直观。</p><h2 id="序列对象的引用"><a href="#序列对象的引用" class="headerlink" title="序列对象的引用"></a>序列对象的引用</h2><p>python中的list,tuple,range这三类都属于序列对象，他们各自有不同的特性，适用于不同的场景，他们有一个共同的特点就是他们的对象都是一个序列，可以简单的理解成是一个数组。</p><p>下面是我们一个常见的对一个list对象的引用：</p><pre><code>li=[1,2,3,4,5,6,7,8]               # 定义一个从1-8的list对象lia=li[3]                                  # 变量a指向对象li中的第三个元素的引用</code></pre><p>这是一个很常见的引用，就像我们在C#中通过数组下标来访问一个数组成员一样。<br>在python中，它相当于是调用了li对象的__getitem__()方法来访问list中的成员一样:</p><pre><code>li.__getitem__(3)</code></pre><p>可以思考一下，这个__getitem__()方法是如何定义的？</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>在python中，函数也是一种对象。实际上，任何一个有__call__()特殊方法的对象都被当作是函数。比如下面的例子：</p><pre><code>class SampleMore(object):     # 定义一个类,其__call__()方法接收一个参数a并返回a+5        def __call__(self,a):                return a+5add = SampleMore()            # 实例化这个类,并用add变量引用这个类的对象。add(2)                        # 调用这个对象的方法，实际上就是调用__call__()方法map(add,[2, 4, 5])            # 将add作为函数依次作用到这个list中。</code></pre><p>add作为SampleMore类的一个对象，当被当作函数来调用时，add执行加5的操作。add还可以作为函数对象，被传递给map()函数。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于内置的对象(比如整数、表、字符串等)，它们所需要的特殊方法都已经在Python中准备好了。而用户自己定义的对象也可以通过增加特殊方法，来实现自定义的语法。特殊方法比较靠近Python的底层，许多Python功能的实现都要依赖于特殊方法。我们将在以后看到更多的例子。</p><p>参考</p><blockquote><p> <a href="http://www.cnblogs.com/vamei/archive/2012/11/19/2772441.html" target="_blank" rel="noopener">Python深入01 特殊方法与多范式</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Python一切皆对象，但同时，Python还是一个多范式语言(multi-paradigm),你不仅可以使用面向对象的方式来编写程序，还可以用面向过程的方式来编写相同功能的程序(还有函数式、声明式等，我们暂不深入)。Python的多范式依赖于Python对象中的特殊方法(special method)。&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="https://fengzhao.me/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式之工厂模式</title>
    <link href="https://fengzhao.me/2016/10/04/2016-10-4-factorypattern/"/>
    <id>https://fengzhao.me/2016/10/04/2016-10-4-factorypattern/</id>
    <published>2016-10-04T08:00:00.000Z</published>
    <updated>2018-05-08T12:26:46.642Z</updated>
    
    <content type="html"><![CDATA[<p>工厂模式作为最常用的java设计模式，在Java和Android的设计中，很多地方都有体现出来，相信对于经常调用各种API的朋友来说，对通过各种factory方法来生成一个对象的方法都非常熟悉了，今天我们就来研究一下这种设计模式。</p><a id="more"></a><h2 id="工厂模式的种类"><a href="#工厂模式的种类" class="headerlink" title="工厂模式的种类"></a>工厂模式的种类</h2><p>通过网络上的一些资料，我了解到工厂模式一般包括三种模式：</p><ol><li>简单工厂模式：</li><li>工厂方法模式</li><li>抽象工厂模式</li></ol><h2 id="简单工厂模式（SimpleFactory）"><a href="#简单工厂模式（SimpleFactory）" class="headerlink" title="简单工厂模式（SimpleFactory）"></a>简单工厂模式（SimpleFactory）</h2><p>简单工厂模式（SimpleFactory）：定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。因为在简单工厂模式中用于创建实例的方法是静态(static)方法，因此简单工厂模式又被称为静态工厂方法(Static Factory Method)模式。</p><p>通过上面的定义，我们基本上也可以概括出它的实现思路：</p><ol><li>将要创建的各种对象封装到不同的类中，这些类被成为具体产品类。</li><li>把具体产品的公共代码，进行抽象后封装到一个抽象类中，这个类被成为抽象产品类，每一个具体产品类都是抽象产品类的子类。</li><li>创建一个工厂类，里面提供一个工厂方法用于创建各种产品，该方法可以通过传入的不同参数，来判断并返回不同的具体产品对象。</li><li>客户端要想创建产品的时候，只需要通过调用工厂类中的工厂方法并传入相应的参数，即可返回相应的对象。</li></ol><p>下面是一个简单的代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明抽象产品类，在设计的时候，需要对具体产品类进行抽象，里面封装了各种产品对象的公有方法。</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//所有产品类的公共业务方法  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodSame</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="comment">//公共方法的实现  </span></span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//声明抽象业务方法，每个类独有的实现，必须在子类中被实现  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">methodDiff</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//声明具体产品类A，每一个具体产品类都继承自抽象产品类，需要重写在父类中声明的抽象方法。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductA</span> <span class="keyword">extends</span> <span class="title">Product</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//实现业务方法  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodDiff</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="comment">//业务方法的实现  </span></span><br><span class="line">    &#125;  </span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//声明一个具体产品类B</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">ProductB</span> <span class="keyword">extends</span> <span class="title">Product</span> </span>&#123;  </span><br><span class="line">        <span class="comment">//实现业务方法  </span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodDiff</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">            <span class="comment">//业务方法的实现  </span></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//工厂类，静态方法Product接收一个参数，根据传入不同的参数，来返回不同类型的对象。即不同的产品</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductFactory</span></span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Product <span class="title">getProuduct</span><span class="params">(String args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(args)</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="keyword">case</span> A:</span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">new</span> ProductA();</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">case</span> B:</span><br><span class="line">              <span class="keyword">return</span>  <span class="keyword">new</span> ProductB();  </span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">          <span class="keyword">default</span>:<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单工厂模式的核心在于，可以通过类名直接调用其静态工厂方法，传入一个正确的参数，来返回需要的对象，在实际开发中，还可以将参数保存在xml格式的文件中，通过静态方法来读取，修改参数时无需直接修改源代码。</p><p>核心问题：通过这种模式，最大的问题在于工厂方法承担的职责过重，里面继承了所有常见的创建逻辑，二是可拓展性不高，试想如果要增加新的产品类，则必须要修改工厂方法，当产品类型较多时，逻辑过于复杂，难以维护。</p><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><p>工厂方法模式，是在简单工厂模式中，根据具体产品类，来定义多个工厂类，每个工厂类，只负责生产单一的具体产品对象。这也符合了单一职责原则。</p><p>工厂方法模式（Factory Pattern）：定义一个用于创建对象的接口，让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。工厂方法模式又简称为工厂模式(Factory Pattern)，又可称作虚拟构造器模式(Virtual Constructor Pattern)或多态工厂模式(Polymorphic Factory Pattern)。</p><p>通过上面的定义，我们基本上也可以概括出它的实现思路：</p><ol><li>定义多个具体产品类，并抽象出其父类。</li><li>定义多个具体工厂类，每一个工厂类负责生产对应的具体产品对象，定义抽象工厂类，里面声明工厂方法，具体的工厂方法，由继承自它的具体工厂类自己去实现。</li><li>客户端通过调用不同的工厂方法，来返回不同的具体产品对象。</li></ol><p>与简单工厂相比，工厂方法模式也增加了工厂类的抽象与继承层次结构，需要注意的一点是，工厂父类中的工厂方法，不能被声明为static，因为工厂方法实际都是由其子类去动态调用，所以这里需要注意。</p><p>下面是一个简单的工厂类代码示例，产品类代码不变：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">abstract</span>  <span class="title">Product</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span>  <span class="title">Product</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProductA</span> <span class="keyword">extends</span> <span class="title">Product</span></span>&#123;</span><br><span class="line">   <span class="keyword">private</span>  String name;</span><br><span class="line">   <span class="keyword">private</span>  <span class="keyword">int</span> age;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ProductA</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.name=name;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ProductA</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.age=age;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象工厂类</span></span><br><span class="line"> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">absFactory</span></span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> Product <span class="title">getProuduct</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;        </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象工厂类A，返回产品A</span></span><br><span class="line"><span class="keyword">public</span>  <span class="class"><span class="keyword">class</span> <span class="title">ProductAFactory</span> <span class="keyword">extends</span> <span class="title">absFactory</span></span>&#123;</span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  Product <span class="title">getProuduct</span><span class="params">(Sting name)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span>  <span class="keyword">new</span> ProductA(name);      </span><br><span class="line">      &#125;        </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Product <span class="title">getProuduct</span><span class="params">(<span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">     <span class="keyword">return</span>  <span class="keyword">new</span> ProductA(age);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过代码可以发现，我们还可以重载工厂方法，来返回不同的对象，当然，对于一个具体工厂，只能返回同一个类型的产品对象。有的时候，我们还可以对客户端隐藏工厂方法，既在工厂方法中直接实例一个产品对象，并直接调用该对象的方法。</p><p>核心问题：在添加新的产品的时候，需要添加新的产品类和对应的工厂类，系统中类的个数双倍增长，会带来额外的开销。</p><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>在工厂方法模式中，每一个具体的工厂类都返回一个具体产品对象，这样造成了巨大的浪费，我们想想，能否在在每一个工厂类中，返回多个产品呢，当然，这是可以的。这就是我们要讲的抽象工厂模式。</p><p>抽象工厂模式(Abstract Factory Pattern)：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。抽象工厂模式又称为Kit模式。</p><p>在抽象工厂模式中，每一个具体工厂都提供了多个工厂方法用于产生多种不同类型的产品，这些产品构成了一个产品族。与工厂方法模式中工厂类与产品类都是一对一的关系不同。抽象工厂是多对多的关系，笔者曾经尝试用文字来描述这种关系，最终宣告失败，下面我们用代码来描述一下它的具体实现方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象工厂</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactory</span> </span>&#123;  </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> AbstractProductA <span class="title">createProductA</span><span class="params">()</span></span>; <span class="comment">//工厂方法A只生产A产品</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> AbstractProductB <span class="title">createProductB</span><span class="params">()</span></span>; <span class="comment">//工厂方法B只生产B产品</span></span><br><span class="line">……  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//工厂1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory1</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//工厂1中的方法A，生产A1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AbstractProductA <span class="title">createProductA</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProductA1();  </span><br><span class="line">  &#125;  </span><br><span class="line">    <span class="comment">//工厂1中的方法B，生产B1</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AbstractProductB <span class="title">createProductB</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProductB1();  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//工厂2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteFactory2</span> <span class="keyword">extends</span> <span class="title">AbstractFactory</span> </span>&#123;  </span><br><span class="line">    <span class="comment">//工厂2中的方法A，生产A2</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AbstractProductA <span class="title">createProductA</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProductA2();  </span><br><span class="line">  &#125;  </span><br><span class="line">    <span class="comment">//工厂2中的方法B，生产B2  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> AbstractProductB <span class="title">createProductB</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ConcreteProductB2();  </span><br><span class="line">  &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//抽象产品A</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractProductA</span></span>&#123;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//由1工厂生产的产品A</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteProductA1</span> <span class="keyword">extends</span> <span class="title">AbstractProductA</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">//由2工厂生产的产品A  </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteProductA2</span> <span class="keyword">extends</span> <span class="title">AbstractProductA</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">//抽象产品B</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractProductB</span></span>&#123;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//由1工厂生产的产品B</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteProductB1</span> <span class="keyword">extends</span> <span class="title">AbstractProductB</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">//由2工厂生产的产品B</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteProductB2</span> <span class="keyword">extends</span> <span class="title">AbstractProductB</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>通过这段代码，相信你可以很快理解抽象工厂模式的使用方法，在抽象工厂模式中，最最重要的就是抽象工厂中的抽象方法，它的设计决定了整个代码的关键。<br>抽象工厂模式是工厂方法模式的进一步延伸，由于它提供了功能更为强大的工厂类并且具备较好的可扩展性，在软件开发中得以广泛应用，尤其是在一些框架和API类库的设计中，例如在Java语言的AWT（抽象窗口工具包）中就使用了抽象工厂模式，它使用抽象工厂模式来实现在不同的操作系统中应用程序呈现与所在操作系统一致的外观界面。抽象工厂模式也是在软件开发中最常用的设计模式之一。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;工厂模式作为最常用的java设计模式，在Java和Android的设计中，很多地方都有体现出来，相信对于经常调用各种API的朋友来说，对通过各种factory方法来生成一个对象的方法都非常熟悉了，今天我们就来研究一下这种设计模式。&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="https://fengzhao.me/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java设计模式之单例模式</title>
    <link href="https://fengzhao.me/2016/09/25/singleton/"/>
    <id>https://fengzhao.me/2016/09/25/singleton/</id>
    <published>2016-09-25T06:00:00.000Z</published>
    <updated>2018-05-08T12:30:58.637Z</updated>
    
    <content type="html"><![CDATA[<p>单例模式作为最简单的设计模式，也是面试中经常会被问到的，笔者在刚学java没多久的时候，就曾经在面试中被要求手写一个单例模式，于是写下这篇文章，来整理几种单例的写法。</p><a id="more"></a><h2 id="什么是单例模式？"><a href="#什么是单例模式？" class="headerlink" title="什么是单例模式？"></a>什么是单例模式？</h2><p>我们来看看维基百科的定义：</p><blockquote><p>单例模式，也叫单子模式，是一种常用的软件设计模式。在应用这个模式时，单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个的全局对象，这样有利于我们协调系统整体的行为。比如在某个服务器程序中，该服务器的配置信息存放在一个文件中，这些配置数据由一个单例对象统一读取，然后服务进程中的其他对象再通过这个单例对象获取这些配置信息。这种方式简化了在复杂环境下的配置管理。</p></blockquote><p>简单的概括一下：意思就是我们系统中在实例化一个类的时候，希望这个类的对象是唯一的，不可以重复实例化。</p><h2 id="单例模式的设计思路"><a href="#单例模式的设计思路" class="headerlink" title="单例模式的设计思路"></a>单例模式的设计思路</h2><p>1.给要被实例化的类添加一个private构造函数，防止从外部通过new关键字来实例化该对象。<br>2.给该类定义一个私有静态变量，创建这个类的唯一实例。<br>3.在该类中定义一个静态方法，通过类名可以来获取该上面定义的实例。（必须是静态方法，通常使用getInstance这个名称）。</p><p>思考：为什么第2步中定义的变量必须是静态的呢？<br>因为我们在第三步是通过类的静态方法来返回这个变量，获取当前类的实例，如果不声明为静态变量，那么这个变量只有在当前类被实例化后才能被访问，我们就无法在第三步使用静态方法来访问这个变量，并返回了。</p><h2 id="饿汉式static-final-field"><a href="#饿汉式static-final-field" class="headerlink" title="饿汉式static final field"></a>饿汉式static final field</h2><p>饿汉式单例作为最简单的实现方式，通过上面的设计思路，我们可以很简单的设计出来。当初我被问到如何实现一个单例模式的时候，我第一反应是写了如下的代码，从Java编程思想中第六章中学到的一段代码。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance= <span class="keyword">new</span> Singleton();</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当类被加载时，静态变量instance会被初始化，此时类的私有构造函数会被调用，单例类的唯一实例将被创建。缺点是当类加载时会自动实例化。</p><h2 id="懒汉式，线程不安全"><a href="#懒汉式，线程不安全" class="headerlink" title="懒汉式，线程不安全"></a>懒汉式，线程不安全</h2><p>如何解决上面的自动加载问题呢？我们使用懒汉式单例，在定义静态变量的时候并不初始化。这种技术被成为懒加载技术(Lazy initialization)，只有在需要的时候，才会通过getInstance方法来加载实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">       instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码比较简单，但是存在致命问题，当有多个线程并行调用getInstance()的时候，还是会创建多个实例，也就是说在多线程下无法正常工作。</p><h2 id="懒汉式，线程安全"><a href="#懒汉式，线程安全" class="headerlink" title="懒汉式，线程安全"></a>懒汉式，线程安全</h2><p>为了解决上面的问题，避免多个线程同时调用getInstance方法，我们在getInstance方法前面增加一个关键字synchronized，来设置同步。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是每次调用每次调用getInstance()时都需要进行线程锁定判断，在多线程高并发访问环境中，将会导致系统性能大大降低。</p><h2 id="双重校验锁"><a href="#双重校验锁" class="headerlink" title="双重校验锁"></a>双重校验锁</h2><p>双重检查锁定(Double-Check Locking)，是一种使用同步块加锁的方法。因为会有两次检查 instance == null，一次是在同步块外，一次是在同步块内。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;   </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;   </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;   </span><br><span class="line">        <span class="comment">//第一重判断  </span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            <span class="comment">//锁定代码块  </span></span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;  </span><br><span class="line">                <span class="comment">//第二重判断  </span></span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton(); <span class="comment">//创建单例实例  </span></span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> instance;   </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，如果使用双重检查锁定来实现懒汉式单例类，需要在静态成员变量instance之前增加修饰符volatile，被volatile修饰的成员变量可以确保多个线程都能够正确处理，且该代码只能在JDK 1.5及以上版本中才能正确执行。由于volatile关键字会屏蔽Java虚拟机所做的一些代码优化，可能会导致系统运行效率降低，因此即使使用双重检查锁定来实现单例模式也不是一种完美的实现方式。</p><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>懒汉式单例饿汉式单例类不能实现延迟加载，不管将来用不用始终占据内存；懒汉式单例类线程安全控制烦琐，而且性能受影响。我们使用一种更好的办法，被称之为Initialization Demand Holder (IoDH)的技术。这种方法使用内部类来实现，我们在单例类中增加一个静态(static)内部类，在该内部类中创建单例对象，再将该单例对象通过getInstance()方法返回给外部使用。</p><p>我比较倾向与使用静态内部类的方法，这种方法也是&lt;<effective java="">&gt;上推荐的。</effective></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Initialization on Demand Holder  </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HolderClass</span> </span>&#123;  </span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> HolderClass.instance;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>由于静态单例对象没有作为singleton的成员变量直接实例化，所以不会在类加载的时候实例化。所以它是懒汉式的，在第一次调用getInstance的时候，将加载内部类，在内部类中定义static类型的变量instance并初始化，由jvm来保证其线程安全，由于getInstance方法没有任何线程锁定，因此其性能不会造成任何影响。通过这种方法，我们既可以实现懒加载，又可以保证线程安全，所以我认为这是实现单例最方便简单的方式。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>单例模式作为一种目标明确、结构简单、理解容易的设计模式，在软件开发中使用频率相当高，在很多应用软件和框架中都得以广泛应用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;单例模式作为最简单的设计模式，也是面试中经常会被问到的，笔者在刚学java没多久的时候，就曾经在面试中被要求手写一个单例模式，于是写下这篇文章，来整理几种单例的写法。&lt;/p&gt;
    
    </summary>
    
    
      <category term="设计模式" scheme="https://fengzhao.me/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
